import {
  Fragment,
  Teleport,
  camelize,
  cloneVNode,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  customRef,
  defineComponent,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  guardReactiveProps,
  h,
  inject,
  isRef,
  mergeDefaults,
  mergeProps,
  nextTick,
  normalizeProps,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onScopeDispose,
  onUnmounted,
  onUpdated,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  toHandlerKey,
  toRaw,
  toRef,
  toRefs,
  unref,
  useSlots,
  vModelDynamic,
  vModelSelect,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-UJJZ7LWV.js";
import "./chunk-SSYGV25P.js";

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr2 = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl2 : lr2;
      return isStart ? lr2 : rl2;
    case "left":
    case "right":
      return isStart ? tb : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const overflowAvailableHeight = height - overflow[heightSide];
      const overflowAvailableWidth = width - overflow[widthSide];
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        const maximumClippingWidth = width - overflow.left - overflow.right;
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/vue/dist/floating-ui.vue.esm.js
import { unref as unref2, computed as computed2, ref as ref2, shallowRef as shallowRef2, watch as watch2, getCurrentScope as getCurrentScope2, onScopeDispose as onScopeDispose2, shallowReadonly } from "vue-demi";
function unwrapElement2(element) {
  var _$el;
  return (_$el = element == null ? void 0 : element.$el) != null ? _$el : element;
}
function arrow2(options) {
  return {
    name: "arrow",
    options,
    fn(args) {
      const element = unwrapElement2(unref2(options.element));
      if (element == null) {
        return {};
      }
      return arrow({
        element,
        padding: options.padding
      }).fn(args);
    }
  };
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed2(() => {
    var _unref;
    return (_unref = unref2(options.open)) != null ? _unref : true;
  });
  const middlewareOption = computed2(() => unref2(options.middleware));
  const placementOption = computed2(() => {
    var _unref2;
    return (_unref2 = unref2(options.placement)) != null ? _unref2 : "bottom";
  });
  const strategyOption = computed2(() => {
    var _unref3;
    return (_unref3 = unref2(options.strategy)) != null ? _unref3 : "absolute";
  });
  const transformOption = computed2(() => {
    var _unref4;
    return (_unref4 = unref2(options.transform)) != null ? _unref4 : true;
  });
  const referenceElement = computed2(() => unwrapElement2(reference.value));
  const floatingElement = computed2(() => unwrapElement2(floating.value));
  const x = ref2(0);
  const y = ref2(0);
  const strategy = ref2(strategyOption.value);
  const placement = ref2(placementOption.value);
  const middlewareData = shallowRef2({});
  const isPositioned = ref2(false);
  const floatingStyles = computed2(() => {
    const initialStyles = {
      position: strategy.value,
      left: "0",
      top: "0"
    };
    if (!floatingElement.value) {
      return initialStyles;
    }
    const xVal = roundByDPR(floatingElement.value, x.value);
    const yVal = roundByDPR(floatingElement.value, y.value);
    if (transformOption.value) {
      return {
        ...initialStyles,
        transform: "translate(" + xVal + "px, " + yVal + "px)",
        ...getDPR(floatingElement.value) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy.value,
      left: xVal + "px",
      top: yVal + "px"
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    computePosition2(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x.value = position.x;
      y.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = true;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch2([middlewareOption, placementOption, strategyOption], update, {
    flush: "sync"
  });
  watch2([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch2(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope2()) {
    onScopeDispose2(cleanup);
  }
  return {
    x: shallowReadonly(x),
    y: shallowReadonly(y),
    strategy: shallowReadonly(strategy),
    placement: shallowReadonly(placement),
    middlewareData: shallowReadonly(middlewareData),
    isPositioned: shallowReadonly(isPositioned),
    floatingStyles,
    update
  };
}

// node_modules/radix-vue/dist/index.js
function H(o, t) {
  const e = typeof o == "string" && !t ? `${o}Context` : t, n = Symbol(e);
  return [(r) => {
    const l = inject(n, r);
    if (l || l === null)
      return l;
    throw new Error(
      `Injection \`${n.toString()}\` not found. Component must be used within ${Array.isArray(o) ? `one of the following components: ${o.join(
        ", "
      )}` : `\`${o}\``}`
    );
  }, (r) => {
    provide(n, r);
  }];
}
function uo(o, t, e) {
  const n = e.originalEvent.target, s = new CustomEvent(o, {
    bubbles: false,
    cancelable: true,
    detail: e
  });
  t && n.addEventListener(o, t, { once: true }), n.dispatchEvent(s);
}
function Ra(o, t) {
  var e;
  const n = shallowRef();
  return watchEffect(() => {
    n.value = o();
  }, {
    ...t,
    flush: (e = t == null ? void 0 : t.flush) != null ? e : "sync"
  }), readonly(n);
}
function Fa(o, t) {
  let e, n, s;
  const i = ref(true), r = () => {
    i.value = true, s();
  };
  watch(o, r, { flush: "sync" });
  const l = typeof t == "function" ? t : t.get, u = typeof t == "function" ? void 0 : t.set, d = customRef((c, p) => (n = c, s = p, {
    get() {
      return i.value && (e = l(), i.value = false), n(), e;
    },
    set(f) {
      u == null || u(f);
    }
  }));
  return Object.isExtensible(d) && (d.trigger = r), d;
}
function st(o) {
  return getCurrentScope() ? (onScopeDispose(o), true) : false;
}
function xt(o) {
  let t = false, e;
  const n = effectScope(true);
  return (...s) => (t || (e = n.run(() => o(...s)), t = true), e);
}
function ge(o) {
  return typeof o == "function" ? o() : unref(o);
}
var Pe = typeof window < "u" && typeof document < "u";
var Va = (o) => typeof o < "u";
var La = Object.prototype.toString;
var Ka = (o) => La.call(o) === "[object Object]";
var Yo = (o, t, e) => Math.min(e, Math.max(t, o));
var Qe = () => {
};
function Na(o, t) {
  function e(...n) {
    return new Promise((s, i) => {
      Promise.resolve(o(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(s).catch(i);
    });
  }
  return e;
}
function Ha(o, t = {}) {
  let e, n, s = Qe;
  const i = (l) => {
    clearTimeout(l), s(), s = Qe;
  };
  return (l) => {
    const u = ge(o), d = ge(t.maxWait);
    return e && i(e), u <= 0 || d !== void 0 && d <= 0 ? (n && (i(n), n = null), Promise.resolve(l())) : new Promise((c, p) => {
      s = t.rejectOnCancel ? p : c, d && !n && (n = setTimeout(() => {
        e && i(e), n = null, c(l());
      }, d)), e = setTimeout(() => {
        n && i(n), n = null, c(l());
      }, u);
    });
  };
}
function Wa(...o) {
  if (o.length !== 1)
    return toRef(...o);
  const t = o[0];
  return typeof t == "function" ? readonly(customRef(() => ({ get: t, set: Qe }))) : ref(t);
}
function co(o, t = 1e4) {
  return customRef((e, n) => {
    let s = ge(o), i;
    const r = () => setTimeout(() => {
      s = ge(o), n();
    }, ge(t));
    return st(() => {
      clearTimeout(i);
    }), {
      get() {
        return e(), s;
      },
      set(l) {
        s = l, n(), clearTimeout(i), i = r();
      }
    };
  });
}
function po(o, t = 200, e = {}) {
  return Na(
    Ha(t, e),
    o
  );
}
function fo(o, t, e = {}) {
  const {
    immediate: n = true
  } = e, s = ref(false);
  let i = null;
  function r() {
    i && (clearTimeout(i), i = null);
  }
  function l() {
    s.value = false, r();
  }
  function u(...d) {
    r(), s.value = true, i = setTimeout(() => {
      s.value = false, i = null, o(...d);
    }, ge(t));
  }
  return n && (s.value = true, Pe && u()), st(l), {
    isPending: readonly(s),
    start: u,
    stop: l
  };
}
function za(o = 1e3, t = {}) {
  const {
    controls: e = false,
    callback: n
  } = t, s = fo(
    n ?? Qe,
    o,
    t
  ), i = computed(() => !s.isPending.value);
  return e ? {
    ready: i,
    ...s
  } : i;
}
function ja(o, t, e) {
  const n = watch(o, (...s) => (nextTick(() => n()), t(...s)), e);
}
function ve(o) {
  var t;
  const e = ge(o);
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
var $t = Pe ? window : void 0;
function et(...o) {
  let t, e, n, s;
  if (typeof o[0] == "string" || Array.isArray(o[0]) ? ([e, n, s] = o, t = $t) : [t, e, n, s] = o, !t)
    return Qe;
  Array.isArray(e) || (e = [e]), Array.isArray(n) || (n = [n]);
  const i = [], r = () => {
    i.forEach((c) => c()), i.length = 0;
  }, l = (c, p, f, m) => (c.addEventListener(p, f, m), () => c.removeEventListener(p, f, m)), u = watch(
    () => [ve(t), ge(s)],
    ([c, p]) => {
      if (r(), !c)
        return;
      const f = Ka(p) ? { ...p } : p;
      i.push(
        ...e.flatMap((m) => n.map((C) => l(c, m, C, f)))
      );
    },
    { immediate: true, flush: "post" }
  ), d = () => {
    u(), r();
  };
  return st(d), d;
}
function Ua(o) {
  return typeof o == "function" ? o : typeof o == "string" ? (t) => t.key === o : Array.isArray(o) ? (t) => o.includes(t.key) : () => true;
}
function vo(...o) {
  let t, e, n = {};
  o.length === 3 ? (t = o[0], e = o[1], n = o[2]) : o.length === 2 ? typeof o[1] == "object" ? (t = true, e = o[0], n = o[1]) : (t = o[0], e = o[1]) : (t = true, e = o[0]);
  const {
    target: s = $t,
    eventName: i = "keydown",
    passive: r = false,
    dedupe: l = false
  } = n, u = Ua(t);
  return et(s, i, (c) => {
    c.repeat && ge(l) || u(c) && e(c);
  }, r);
}
function Pt() {
  const o = ref(false);
  return getCurrentInstance() && onMounted(() => {
    o.value = true;
  }), o;
}
function Ga(o) {
  const t = Pt();
  return computed(() => (t.value, !!o()));
}
function qa(o, t = {}) {
  const {
    immediate: e = true,
    fpsLimit: n = void 0,
    window: s = $t
  } = t, i = ref(false), r = n ? 1e3 / n : null;
  let l = 0, u = null;
  function d(f) {
    if (!i.value || !s)
      return;
    const m = f - (l || f);
    if (r && m < r) {
      u = s.requestAnimationFrame(d);
      return;
    }
    o({ delta: m, timestamp: f }), l = f, u = s.requestAnimationFrame(d);
  }
  function c() {
    !i.value && s && (i.value = true, u = s.requestAnimationFrame(d));
  }
  function p() {
    i.value = false, u != null && s && (s.cancelAnimationFrame(u), u = null);
  }
  return e && c(), st(p), {
    isActive: readonly(i),
    pause: p,
    resume: c
  };
}
function Ya(o) {
  return JSON.parse(JSON.stringify(o));
}
function Ce(o, t, e = {}) {
  const { window: n = $t, ...s } = e;
  let i;
  const r = Ga(() => n && "ResizeObserver" in n), l = () => {
    i && (i.disconnect(), i = void 0);
  }, u = computed(() => Array.isArray(o) ? o.map((p) => ve(p)) : [ve(o)]), d = watch(
    u,
    (p) => {
      if (l(), r.value && n) {
        i = new ResizeObserver(t);
        for (const f of p)
          f && i.observe(f, s);
      }
    },
    { immediate: true, flush: "post", deep: true }
  ), c = () => {
    l(), d();
  };
  return st(c), {
    isSupported: r,
    stop: c
  };
}
function Xa(o, t) {
  const e = shallowRef(t);
  return watch(
    Wa(o),
    (n, s) => {
      e.value = s;
    },
    { flush: "sync" }
  ), readonly(e);
}
function X(o, t, e, n = {}) {
  var s, i, r;
  const {
    clone: l = false,
    passive: u = false,
    eventName: d,
    deep: c = false,
    defaultValue: p,
    shouldEmit: f
  } = n, m = getCurrentInstance(), C = e || (m == null ? void 0 : m.emit) || ((s = m == null ? void 0 : m.$emit) == null ? void 0 : s.bind(m)) || ((r = (i = m == null ? void 0 : m.proxy) == null ? void 0 : i.$emit) == null ? void 0 : r.bind(m == null ? void 0 : m.proxy));
  let _ = d;
  t || (t = "modelValue"), _ = _ || `update:${t.toString()}`;
  const $ = (P) => l ? typeof l == "function" ? l(P) : Ya(P) : P, E = () => Va(o[t]) ? $(o[t]) : p, w = (P) => {
    f ? f(P) && C(_, P) : C(_, P);
  };
  if (u) {
    const P = E(), B = ref(P);
    let I = false;
    return watch(
      () => o[t],
      (A) => {
        I || (I = true, B.value = $(A), nextTick(() => I = false));
      }
    ), watch(
      B,
      (A) => {
        !I && (A !== o[t] || c) && w(A);
      },
      { deep: c }
    ), B;
  } else
    return computed({
      get() {
        return E();
      },
      set(P) {
        w(P);
      }
    });
}
function Bt(o) {
  return o ? o.flatMap((t) => t.type === Fragment ? Bt(t.children) : [t]) : [];
}
function St(o, t, e, n = {}) {
  if (!t)
    return null;
  const {
    arrowKeyOptions: s = "both",
    attributeName: i = "data-radix-vue-collection-item",
    itemsArray: r = [],
    loop: l = true,
    dir: u = "ltr",
    preventScroll: d = true,
    focus: c = false
  } = n, [p, f, m, C, _, $] = [
    o.key === "ArrowRight",
    o.key === "ArrowLeft",
    o.key === "ArrowUp",
    o.key === "ArrowDown",
    o.key === "Home",
    o.key === "End"
  ], E = m || C, w = p || f;
  if (!_ && !$ && (!E && !w || s === "vertical" && w || s === "horizontal" && E))
    return null;
  const P = e ? Array.from(e.querySelectorAll(`[${i}]`)) : r;
  if (!P.length)
    return null;
  d && o.preventDefault();
  let B = null;
  return w || E ? B = vn(P, t, {
    goForward: E ? C : u === "ltr" ? p : f,
    loop: l
  }) : _ ? B = P.at(0) || null : $ && (B = P.at(-1) || null), c && (B == null || B.focus()), B;
}
function vn(o, t, { goForward: e, loop: n }, s = o.length) {
  if (--s === 0)
    return null;
  const i = o.indexOf(t), r = e ? i + 1 : i - 1;
  if (!n && (r < 0 || r >= o.length))
    return null;
  const l = (r + o.length) % o.length, u = o[l];
  return u ? u.hasAttribute("disabled") && u.getAttribute("disabled") !== "false" ? vn(
    o,
    u,
    { goForward: e, loop: n },
    s
  ) : u : null;
}
function Gt(o) {
  return o !== null && typeof o == "object";
}
function Zt(o, t, e = ".", n) {
  if (!Gt(t))
    return Zt(o, {}, e, n);
  const s = Object.assign({}, t);
  for (const i in o) {
    if (i === "__proto__" || i === "constructor")
      continue;
    const r = o[i];
    r != null && (n && n(s, i, r, e) || (Array.isArray(r) && Array.isArray(s[i]) ? s[i] = [...r, ...s[i]] : Gt(r) && Gt(s[i]) ? s[i] = Zt(
      r,
      s[i],
      (e ? `${e}.` : "") + i.toString(),
      n
    ) : s[i] = r));
  }
  return s;
}
function Ja(o) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((e, n) => Zt(e, n, "", o), {})
  );
}
var Za = Ja();
var [mn, Qa] = H("ConfigProvider");
var Tl = defineComponent({
  __name: "ConfigProvider",
  props: {
    dir: { default: "ltr" },
    scrollBody: { type: [Boolean, Object], default: true }
  },
  setup(o) {
    const t = o, { dir: e, scrollBody: n } = toRefs(t);
    return Qa({
      dir: e,
      scrollBody: n
    }), (s, i) => renderSlot(s.$slots, "default");
  }
});
var es = xt(() => ref());
var ts = xt(() => ref(0));
function it(o) {
  const t = mn({
    scrollBody: ref(true)
  }), e = ts(), n = es(), s = ref(o), i = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.body.style.removeProperty("--scrollbar-width"), document.body.style.overflow = n.value ?? "", n.value = void 0;
  };
  return o && e.value++, watch(s, (r) => {
    var l;
    if (Pe && r) {
      n.value === void 0 && (n.value = document.body.style.overflow);
      const u = window.innerWidth - document.documentElement.clientWidth, d = { padding: u, margin: 0 }, c = (l = t.scrollBody) != null && l.value ? typeof t.scrollBody.value == "object" ? Za({
        padding: t.scrollBody.value.padding === true ? u : t.scrollBody.value.padding,
        margin: t.scrollBody.value.margin === true ? u : t.scrollBody.value.margin
      }, d) : d : { padding: 0, margin: 0 };
      u > 0 && (document.body.style.paddingRight = `${c.padding}px`, document.body.style.marginRight = `${c.margin}px`, document.body.style.setProperty("--scrollbar-width", `${u}px`), document.body.style.overflow = "hidden"), nextTick(() => {
        document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
      });
    }
  }, { immediate: true }), onBeforeUnmount(() => {
    o && e.value--, e.value === 0 && i();
  }), s;
}
var os = "data-radix-vue-collection-item";
function ne(o, t = os) {
  const e = o ?? Symbol();
  return { createCollection: (i) => {
    const r = ref([]);
    function l() {
      const u = ve(i);
      return u ? r.value = Array.from(
        u.querySelectorAll(`[${t}]:not([data-disabled=true])`)
      ) : r.value = [];
    }
    return onBeforeUpdate(() => {
      r.value = [];
    }), onMounted(l), onUpdated(l), watch(() => i == null ? void 0 : i.value, l, { immediate: true }), provide(e, r), r;
  }, injectCollection: () => inject(e, ref([])) };
}
function pe(o) {
  const t = mn({
    dir: ref("ltr")
  });
  return computed(() => {
    var e;
    return (o == null ? void 0 : o.value) || ((e = t.dir) == null ? void 0 : e.value) || "ltr";
  });
}
function le(o) {
  const t = getCurrentInstance(), e = t == null ? void 0 : t.type.emits, n = {};
  return e != null && e.length || console.warn(
    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`
  ), e == null || e.forEach((s) => {
    n[toHandlerKey(camelize(s))] = (...i) => o(s, ...i);
  }), n;
}
var qt = 0;
function mo() {
  watchEffect((o) => {
    if (!Pe)
      return;
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      t[0] ?? Xo()
    ), document.body.insertAdjacentElement(
      "beforeend",
      t[1] ?? Xo()
    ), qt++, o(() => {
      qt === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), qt--;
    });
  });
}
function Xo() {
  const o = document.createElement("span");
  return o.setAttribute("data-radix-focus-guard", ""), o.tabIndex = 0, o.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", o;
}
function ze(o) {
  return computed(() => {
    var t;
    return ge(o) ? !!((t = ve(o)) != null && t.closest("form")) : true;
  });
}
function Tt(o) {
  const t = getCurrentInstance(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((n, s) => {
    const i = (t == null ? void 0 : t.type.props[s]).default;
    return i !== void 0 && (n[s] = i), n;
  }, {});
  return Fa(() => ({ ...o }), () => {
    const n = {}, s = (t == null ? void 0 : t.vnode.props) ?? {};
    return Object.keys(s).forEach((i) => {
      n[camelize(i)] = s[i];
    }), Object.keys({ ...e, ...n }).reduce((i, r) => (o[r] !== void 0 && (i[r] = o[r]), i), {});
  });
}
function ue(o, t) {
  const e = Tt(o), n = t ? le(t) : {};
  return computed(() => ({
    ...e.value,
    ...n
  }));
}
function _e() {
  const o = getCurrentInstance();
  function t(e) {
    typeof e == "object" && (o.exposed = e, o.exposeProxy = e);
  }
  return t;
}
var ns = function(o) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(o) ? o[0] : o;
  return t.ownerDocument.body;
};
var Ne = /* @__PURE__ */ new WeakMap();
var pt = /* @__PURE__ */ new WeakMap();
var ft = {};
var Yt = 0;
var hn = function(o) {
  return o && (o.host || hn(o.parentNode));
};
var as = function(o, t) {
  return t.map(function(e) {
    if (o.contains(e))
      return e;
    var n = hn(e);
    return n && o.contains(n) ? n : (console.error("aria-hidden", e, "in not contained inside", o, ". Doing nothing"), null);
  }).filter(function(e) {
    return !!e;
  });
};
var ss = function(o, t, e, n) {
  var s = as(t, Array.isArray(o) ? o : [o]);
  ft[e] || (ft[e] = /* @__PURE__ */ new WeakMap());
  var i = ft[e], r = [], l = /* @__PURE__ */ new Set(), u = new Set(s), d = function(p) {
    !p || l.has(p) || (l.add(p), d(p.parentNode));
  };
  s.forEach(d);
  var c = function(p) {
    !p || u.has(p) || Array.prototype.forEach.call(p.children, function(f) {
      if (l.has(f))
        c(f);
      else {
        var m = f.getAttribute(n), C = m !== null && m !== "false", _ = (Ne.get(f) || 0) + 1, $ = (i.get(f) || 0) + 1;
        Ne.set(f, _), i.set(f, $), r.push(f), _ === 1 && C && pt.set(f, true), $ === 1 && f.setAttribute(e, "true"), C || f.setAttribute(n, "true");
      }
    });
  };
  return c(t), l.clear(), Yt++, function() {
    r.forEach(function(p) {
      var f = Ne.get(p) - 1, m = i.get(p) - 1;
      Ne.set(p, f), i.set(p, m), f || (pt.has(p) || p.removeAttribute(n), pt.delete(p)), m || p.removeAttribute(e);
    }), Yt--, Yt || (Ne = /* @__PURE__ */ new WeakMap(), Ne = /* @__PURE__ */ new WeakMap(), pt = /* @__PURE__ */ new WeakMap(), ft = {});
  };
};
var is = function(o, t, e) {
  e === void 0 && (e = "data-aria-hidden");
  var n = Array.from(Array.isArray(o) ? o : [o]), s = t || ns(o);
  return s ? (n.push.apply(n, Array.from(s.querySelectorAll("[aria-live]"))), ss(n, s, e, "aria-hidden")) : function() {
    return null;
  };
};
function rt(o) {
  let t;
  watch(() => ve(o), (e) => {
    e ? t = is(e) : t && t();
  }), onUnmounted(() => {
    t && t();
  });
}
var rs = xt(() => ({ count: ref(0) }));
function te(o) {
  const { count: t } = rs();
  return o || t.value++, o || `radix-${t.value}`;
}
function yn(o) {
  const t = ref(), e = computed(() => {
    var s;
    return ((s = t.value) == null ? void 0 : s.width) ?? 0;
  }), n = computed(() => {
    var s;
    return ((s = t.value) == null ? void 0 : s.height) ?? 0;
  });
  return onMounted(() => {
    const s = ve(o);
    if (s) {
      t.value = { width: s.offsetWidth, height: s.offsetHeight };
      const i = new ResizeObserver((r) => {
        if (!Array.isArray(r) || !r.length)
          return;
        const l = r[0];
        let u, d;
        if ("borderBoxSize" in l) {
          const c = l.borderBoxSize, p = Array.isArray(c) ? c[0] : c;
          u = p.inlineSize, d = p.blockSize;
        } else
          u = s.offsetWidth, d = s.offsetHeight;
        t.value = { width: u, height: d };
      });
      return i.observe(s, { box: "border-box" }), () => i.unobserve(s);
    } else
      t.value = void 0;
  }), {
    width: e,
    height: n
  };
}
function gn(o, t) {
  const e = ref(o);
  function n(i) {
    return t[e.value][i] ?? e.value;
  }
  return {
    state: e,
    dispatch: (i) => {
      e.value = n(i);
    }
  };
}
function ho(o) {
  const t = co("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (s) => {
      var p, f;
      t.value = t.value + s;
      const i = o.value, r = document.activeElement, l = ((f = (p = i.find((m) => m === r)) == null ? void 0 : p.textContent) == null ? void 0 : f.trim()) ?? "", u = i.map((m) => {
        var C;
        return ((C = m.textContent) == null ? void 0 : C.trim()) ?? "";
      }), d = ls(u, t.value, l), c = i.find(
        (m) => {
          var C;
          return ((C = m.textContent) == null ? void 0 : C.trim()) === d;
        }
      );
      c && c.focus();
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function yo(o, t) {
  return o.map((e, n) => o[(t + n) % o.length]);
}
function ls(o, t, e) {
  const s = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, i = e ? o.indexOf(e) : -1;
  let r = yo(o, Math.max(i, 0));
  s.length === 1 && (r = r.filter((d) => d !== e));
  const u = r.find(
    (d) => d.toLowerCase().startsWith(s.toLowerCase())
  );
  return u !== e ? u : void 0;
}
var us = defineComponent({
  name: "PrimitiveSlot",
  inheritAttrs: false,
  setup(o, { attrs: t, slots: e }) {
    return () => {
      var r, l;
      if (!e.default)
        return null;
      const n = Bt(e.default()), [s, ...i] = n;
      if (Object.keys(t).length > 0) {
        (r = s.props) == null || delete r.ref;
        const u = mergeProps(t, s.props ?? {});
        t.class && ((l = s.props) != null && l.class) && delete s.props.class;
        const d = cloneVNode(s, u);
        for (const c in u)
          c.startsWith("on") && (d.props || (d.props = {}), d.props[c] = u[c]);
        return n.length === 1 ? d : [d, ...i];
      }
      return n;
    };
  }
});
var D = defineComponent({
  name: "Primitive",
  inheritAttrs: false,
  props: {
    asChild: {
      type: Boolean,
      default: false
    },
    as: {
      type: String,
      default: "div"
    }
  },
  setup(o, { attrs: t, slots: e }) {
    return (o.asChild ? "template" : o.as) !== "template" ? () => h(o.as, t, { default: e.default }) : () => h(us, t, { default: e.default });
  }
});
function V() {
  const o = ref(), t = computed(() => {
    var e, n;
    return ["#text", "#comment"].includes((e = o.value) == null ? void 0 : e.$el.nodeName) ? (n = o.value) == null ? void 0 : n.$el.nextElementSibling : ve(o);
  });
  return {
    primitiveElement: o,
    currentElement: t
  };
}
var [bn, ds] = H("CollapsibleRoot");
var cs = defineComponent({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:open"],
  setup(o, { expose: t, emit: e }) {
    const n = o, i = X(n, "open", e, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), r = X(n, "disabled");
    return ds({
      contentId: te(),
      disabled: r,
      open: i,
      onOpenToggle: () => {
        i.value = !i.value;
      }
    }), t({ open: i }), (l, u) => (openBlock(), createBlock(unref(D), {
      as: l.as,
      "as-child": n.asChild,
      "data-state": n.open ? "open" : "closed",
      "data-disabled": n.disabled ? "" : void 0
    }, {
      default: withCtx(() => [
        renderSlot(l.$slots, "default", { open: unref(i) })
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state", "data-disabled"]));
  }
});
var ps = defineComponent({
  __name: "CollapsibleTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = bn();
    return (n, s) => {
      var i, r;
      return openBlock(), createBlock(unref(D), {
        type: n.as === "button" ? "button" : void 0,
        as: n.as,
        "as-child": t.asChild,
        "aria-controls": unref(e).contentId,
        "aria-expanded": unref(e).open.value,
        "data-state": unref(e).open.value ? "open" : "closed",
        "data-disabled": (i = unref(e).disabled) != null && i.value ? "" : void 0,
        disabled: (r = unref(e).disabled) == null ? void 0 : r.value,
        onClick: unref(e).onOpenToggle
      }, {
        default: withCtx(() => [
          renderSlot(n.$slots, "default")
        ]),
        _: 3
      }, 8, ["type", "as", "as-child", "aria-controls", "aria-expanded", "data-state", "data-disabled", "disabled", "onClick"]);
    };
  }
});
function fs(o, t) {
  const e = ref({}), n = ref("none"), s = o.value ? "mounted" : "unmounted", { state: i, dispatch: r } = gn(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  watch(
    o,
    async (f, m) => {
      var _;
      const C = m !== f;
      if (await nextTick(), C) {
        const $ = n.value, E = vt(t.value);
        f ? r("MOUNT") : E === "none" || ((_ = e.value) == null ? void 0 : _.display) === "none" ? r("UNMOUNT") : r(m && $ !== E ? "ANIMATION_OUT" : "UNMOUNT");
      }
    },
    { immediate: true }
  );
  const l = (f) => {
    const m = vt(t.value), C = m.includes(
      f.animationName
    );
    f.target === t.value && C && r("ANIMATION_END"), f.target === t.value && m === "none" && r("ANIMATION_END");
  }, u = (f) => {
    f.target === t.value && (n.value = vt(t.value));
  }, d = watch(
    t,
    (f, m) => {
      f ? (e.value = getComputedStyle(f), f.addEventListener("animationstart", u), f.addEventListener("animationcancel", l), f.addEventListener("animationend", l)) : (r("ANIMATION_END"), m == null || m.removeEventListener("animationstart", u), m == null || m.removeEventListener("animationcancel", l), m == null || m.removeEventListener("animationend", l));
    },
    { immediate: true }
  ), c = watch(i, () => {
    const f = vt(t.value);
    n.value = i.value === "mounted" ? f : "none";
  });
  return onUnmounted(() => {
    d(), c();
  }), {
    isPresent: computed(
      () => ["mounted", "unmountSuspended"].includes(i.value)
    )
  };
}
function vt(o) {
  return o && getComputedStyle(o).animationName || "none";
}
var ae = defineComponent({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: true
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(o, { slots: t, expose: e }) {
    var d;
    const { present: n, forceMount: s } = toRefs(o), i = ref(), { isPresent: r } = fs(n, i);
    e({ present: r });
    let l = t.default({ present: r });
    l = Bt(l || []);
    const u = getCurrentInstance();
    if (l && (l == null ? void 0 : l.length) > 1) {
      const c = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${c}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.rv",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((p) => `  - ${p}`).join(`
`)
        ].join(`
`)
      );
    }
    return () => s.value || n.value || r.value ? h(t.default({ present: r })[0], {
      ref: (c) => {
        const p = ve(c);
        return typeof (p == null ? void 0 : p.hasAttribute) > "u" || (p != null && p.hasAttribute("data-radix-popper-content-wrapper") ? i.value = p.firstChild : i.value = p), p;
      }
    }) : null;
  }
});
var vs = defineComponent({
  inheritAttrs: false,
  __name: "CollapsibleContent",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = bn(), n = ref(), { primitiveElement: s, currentElement: i } = V(), r = ref(0), l = ref(0), u = computed(() => e.open.value), d = ref(u.value), c = ref();
    return watch(
      () => {
        var p;
        return [u.value, (p = n.value) == null ? void 0 : p.present];
      },
      async () => {
        await nextTick();
        const p = i.value;
        if (!p)
          return;
        c.value = c.value || {
          transitionDuration: p.style.transitionDuration,
          animationName: p.style.animationName
        }, p.style.transitionDuration = "0s", p.style.animationName = "none";
        const f = p.getBoundingClientRect();
        l.value = f.height, r.value = f.width, d.value || (p.style.transitionDuration = c.value.transitionDuration, p.style.animationName = c.value.animationName);
      },
      {
        immediate: true
      }
    ), onMounted(() => {
      requestAnimationFrame(() => {
        d.value = false;
      });
    }), (p, f) => (openBlock(), createBlock(unref(ae), {
      ref_key: "presentRef",
      ref: n,
      present: p.forceMount || unref(e).open.value,
      "force-mount": true
    }, {
      default: withCtx(() => {
        var m, C;
        return [
          createVNode(unref(D), mergeProps(p.$attrs, {
            id: unref(e).contentId,
            ref_key: "primitiveElement",
            ref: s,
            "as-child": t.asChild,
            as: p.as,
            "data-state": unref(e).open.value ? "open" : "closed",
            "data-disabled": (m = unref(e).disabled) != null && m.value ? "true" : void 0,
            hidden: !((C = n.value) != null && C.present),
            style: {
              "--radix-collapsible-content-height": `${l.value}px`,
              "--radix-collapsible-content-width": `${r.value}px`
            }
          }), {
            default: withCtx(() => {
              var _;
              return [
                (_ = n.value) != null && _.present ? renderSlot(p.$slots, "default", { key: 0 }) : createCommentVNode("", true)
              ];
            }),
            _: 3
          }, 16, ["id", "as-child", "as", "data-state", "data-disabled", "hidden", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
});
function ms(o, t) {
  if (o === "single") {
    if (Array.isArray(t)) {
      console.error(`Invalid prop \`value\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`single\`. The \`value\` prop must be:
  - a string
  - \`undefined\`

If you want to use multiple values, use the \`AccordionRoot\` with type \`multiple\`.

Defaulting to \`undefined\`.`);
      return;
    }
  } else if (o === "multiple" && (typeof t == "string" || typeof t > "u"))
    return console.error(`Invalid prop \`value\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`multiple\`. The \`value\` prop must be:
- an array of strings
- empty array (\`[]\`)

If you want to use just one value, use the \`AccordionRoot\` with type \`single\`.

Defaulting to empty array (\`[]\`).`), [];
  return t;
}
function hs({ type: o, defaultValue: t }) {
  if (o === "multiple")
    return Array.isArray(t) ? t : t === void 0 ? [] : (console.error(
      `Invalid prop \`defaultValue\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`multiple\`. The \`defaultValue\` prop must be:
  - an array of strings
  - empty array (\`[]\`)

If you want to use just one value, use the \`AccordionRoot\` with type \`single\`.

Defaulting to empty array (\`[]\`).`
    ), []);
  if (o === "single") {
    if (typeof t == "string")
      return t;
    if (t === void 0)
      return;
    console.error(
      `Invalid prop \`defaultValue\` of value \`${t}\` supplied to \`AccordionRoot\`, which type is \`single\`. The \`defaultValue\` prop must be:
  - a string
  - \`undefined\`

Defaulting to \`undefined\`.`
    );
    return;
  }
}
function Cn(o, t) {
  const e = X(o, "modelValue", t, {
    defaultValue: hs(o),
    passive: o.modelValue === void 0
  });
  watch(
    () => [o.type, o.modelValue],
    () => {
      const s = ms(o.type, e.value);
      e.value !== s && (e.value = s);
    },
    { immediate: true }
  );
  function n(s) {
    if (o.type === "single")
      e.value = s === e.value ? void 0 : s;
    else {
      const i = e.value || [];
      if (i.includes(s)) {
        const r = i.findIndex((l) => l === s);
        i.splice(r, 1);
      } else
        i.push(s);
      e.value = i, t("update:modelValue", e.value);
    }
  }
  return {
    modelValue: e,
    changeModelValue: n
  };
}
var [Ot, ys] = H("AccordionRoot");
var Ol = defineComponent({
  __name: "AccordionRoot",
  props: {
    type: {},
    modelValue: {},
    defaultValue: {},
    collapsible: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    dir: {},
    orientation: { default: "vertical" },
    asChild: { type: Boolean, default: false },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { expose: t, emit: e }) {
    const n = o, s = e, { dir: i, disabled: r } = toRefs(n), l = pe(i), { modelValue: u, changeModelValue: d } = Cn(n, s), { primitiveElement: c, currentElement: p } = V();
    return ys({
      disabled: r,
      direction: l,
      orientation: n.orientation,
      parentElement: p,
      isSingle: computed(() => n.type === "single"),
      collapsible: n.collapsible,
      modelValue: u,
      changeModelValue: d
    }), t({
      modelValue: u
    }), (f, m) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: c,
      "as-child": f.asChild,
      as: f.as
    }, {
      default: withCtx(() => [
        renderSlot(f.$slots, "default", { modelValue: unref(u) })
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
});
var [go, gs] = H("AccordionItem");
var Dl = defineComponent({
  __name: "AccordionItem",
  props: {
    disabled: { type: Boolean },
    value: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o, { expose: t }) {
    const e = o, n = Ot(), s = computed(
      () => n.isSingle.value ? e.value === n.modelValue.value : Array.isArray(n.modelValue.value) && n.modelValue.value.includes(e.value)
    ), i = computed(() => n.disabled.value || e.disabled || n.isSingle.value && s.value && !n.collapsible), r = computed(() => i.value ? "" : void 0), l = computed(
      () => s.value ? "open" : "closed"
      /* Closed */
    ), { primitiveElement: u, currentElement: d } = V();
    gs({
      open: s,
      dataState: l,
      disabled: i,
      dataDisabled: r,
      triggerId: te(),
      primitiveElement: u,
      currentElement: d,
      value: computed(() => e.value)
    });
    function c(p) {
      St(
        p,
        d.value,
        n.parentElement.value,
        {
          arrowKeyOptions: n.orientation,
          dir: n.direction.value,
          focus: true
        }
      );
    }
    return t({ open: s }), (p, f) => (openBlock(), createBlock(unref(cs), {
      "data-orientation": unref(n).orientation,
      "data-disabled": r.value,
      "data-state": l.value,
      disabled: i.value,
      open: s.value,
      "as-child": e.asChild,
      onKeydown: withKeys(c, ["up", "down", "left", "right", "home", "end"])
    }, {
      default: withCtx(() => [
        renderSlot(p.$slots, "default", { open: s.value })
      ]),
      _: 3
    }, 8, ["data-orientation", "data-disabled", "data-state", "disabled", "open", "as-child", "onKeydown"]));
  }
});
var Al = defineComponent({
  __name: "AccordionContent",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Ot(), n = go();
    return (s, i) => (openBlock(), createBlock(unref(vs), {
      id: unref(n).triggerId,
      role: "region",
      open: unref(n).open.value,
      hidden: !unref(n).open.value,
      "as-child": t.asChild,
      "aria-labelledby": unref(n).triggerId,
      "data-state": unref(n).dataState.value,
      "data-disabled": unref(n).dataDisabled.value,
      "data-orientation": unref(e).orientation,
      style: { "--radix-accordion-content-width": "var(--radix-collapsible-content-width)", "--radix-accordion-content-height": "var(--radix-collapsible-content-height)" }
    }, {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "open", "hidden", "as-child", "aria-labelledby", "data-state", "data-disabled", "data-orientation"]));
  }
});
var Il = defineComponent({
  __name: "AccordionHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "h3" }
  },
  setup(o) {
    const t = o, e = Ot(), n = go();
    return (s, i) => (openBlock(), createBlock(unref(D), {
      as: t.as,
      "as-child": t.asChild,
      "data-orientation": unref(e).orientation,
      "data-state": unref(n).dataState.value,
      "data-disabled": unref(n).dataDisabled.value
    }, {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-orientation", "data-state", "data-disabled"]));
  }
});
var Ml = defineComponent({
  __name: "AccordionTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Ot(), n = go();
    function s() {
      n.disabled.value || e.changeModelValue(n.value.value);
    }
    return (i, r) => (openBlock(), createBlock(unref(ps), {
      id: unref(n).triggerId,
      ref: unref(n).primitiveElement,
      "data-radix-vue-collection-item": "",
      as: t.as,
      "as-child": t.asChild,
      "aria-controls": unref(n).triggerId,
      "aria-disabled": unref(n).disabled.value || void 0,
      "aria-expanded": unref(n).open.value || false,
      "data-disabled": unref(n).dataDisabled.value,
      "data-orientation": unref(e).orientation,
      "data-state": unref(n).dataState.value,
      disabled: unref(n).disabled.value,
      onClick: s
    }, {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "as", "as-child", "aria-controls", "aria-disabled", "aria-expanded", "data-disabled", "data-orientation", "data-state", "disabled"]));
  }
});
function bo(o) {
  return o === "indeterminate";
}
function _n(o) {
  return bo(o) ? "indeterminate" : o ? "checked" : "unchecked";
}
var bs = ["value", "checked", "name", "disabled", "required"];
var [Cs, _s] = H("CheckboxRoot");
var kl = defineComponent({
  inheritAttrs: false,
  __name: "CheckboxRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: [Boolean, String], default: void 0 },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    value: { default: "on" },
    id: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(o, { emit: t }) {
    const e = o, n = t, { disabled: s } = toRefs(e), i = X(e, "checked", n, {
      defaultValue: e.defaultChecked,
      passive: e.checked === void 0
    }), { primitiveElement: r, currentElement: l } = V(), u = ze(l), d = computed(() => {
      var c;
      return e.id && l.value ? (c = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : c.innerText : void 0;
    });
    return _s({
      disabled: s,
      state: i
    }), (c, p) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(D), mergeProps(c.$attrs, {
        id: c.id,
        ref_key: "primitiveElement",
        ref: r,
        role: "checkbox",
        "as-child": e.asChild,
        as: c.as,
        type: c.as === "button" ? "button" : void 0,
        "aria-checked": unref(bo)(unref(i)) ? "mixed" : unref(i),
        "aria-required": false,
        "aria-label": c.$attrs["aria-label"] || d.value,
        "data-state": unref(_n)(unref(i)),
        "data-disabled": unref(s) ? "" : void 0,
        disabled: unref(s),
        onKeydown: withKeys(withModifiers(() => {
        }, ["prevent"]), ["enter"]),
        onClick: p[0] || (p[0] = (f) => i.value = !unref(i))
      }), {
        default: withCtx(() => [
          renderSlot(c.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "as-child", "as", "type", "aria-checked", "aria-label", "data-state", "data-disabled", "disabled", "onKeydown"]),
      unref(u) ? (openBlock(), createElementBlock("input", {
        key: 0,
        type: "checkbox",
        tabindex: "-1",
        "aria-hidden": "",
        value: c.value,
        checked: !!unref(i),
        name: e.name,
        disabled: e.disabled,
        required: e.required,
        style: normalizeStyle({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      }, null, 12, bs)) : createCommentVNode("", true)
    ], 64));
  }
});
var Rl = defineComponent({
  __name: "CheckboxIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = Cs();
    return (e, n) => (openBlock(), createBlock(unref(ae), {
      present: e.forceMount || unref(bo)(unref(t).state.value) || unref(t).state.value === true
    }, {
      default: withCtx(() => [
        createVNode(unref(D), mergeProps({
          "data-state": unref(_n)(unref(t).state.value),
          "data-disabled": unref(t).disabled.value ? "" : void 0,
          style: { pointerEvents: "none" },
          "as-child": e.asChild,
          as: e.as
        }, e.$attrs), {
          default: withCtx(() => [
            renderSlot(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "data-disabled", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var [wn, ws] = H("PopperRoot");
var Fe = defineComponent({
  __name: "PopperRoot",
  setup(o) {
    const t = ref();
    return ws({
      anchor: t,
      onAnchorChange: (e) => t.value = e
    }), (e, n) => renderSlot(e.$slots, "default");
  }
});
var Ve = defineComponent({
  __name: "PopperAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = V(), s = wn();
    return watch(n, () => {
      s.onAnchorChange(t.element ?? n.value);
    }), (i, r) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: e,
      as: i.as,
      "as-child": i.asChild
    }, {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function Es(o) {
  return o !== null;
}
function xs(o) {
  return {
    name: "transformOrigin",
    options: o,
    fn(t) {
      var $, E, w;
      const { placement: e, rects: n, middlewareData: s } = t, r = (($ = s.arrow) == null ? void 0 : $.centerOffset) !== 0, l = r ? 0 : o.arrowWidth, u = r ? 0 : o.arrowHeight, [d, c] = Qt(e), p = { start: "0%", center: "50%", end: "100%" }[c], f = (((E = s.arrow) == null ? void 0 : E.x) ?? 0) + l / 2, m = (((w = s.arrow) == null ? void 0 : w.y) ?? 0) + u / 2;
      let C = "", _ = "";
      return d === "bottom" ? (C = r ? p : `${f}px`, _ = `${-u}px`) : d === "top" ? (C = r ? p : `${f}px`, _ = `${n.floating.height + u}px`) : d === "right" ? (C = `${-u}px`, _ = r ? p : `${m}px`) : d === "left" && (C = `${n.floating.width + u}px`, _ = r ? p : `${m}px`), { data: { x: C, y: _ } };
    }
  };
}
function Qt(o) {
  const [t, e = "center"] = o.split("-");
  return [t, e];
}
var En = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: true,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: false,
  updatePositionStrategy: "optimized",
  prioritizePosition: false
};
var [$s, Ps] = H("PopperContent");
var je = defineComponent({
  inheritAttrs: false,
  __name: "PopperContent",
  props: mergeDefaults({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...En
  }),
  setup(o, { expose: t }) {
    const e = o, n = wn(), s = _e(), { primitiveElement: i, currentElement: r } = V(), l = ref(), u = ref(), { width: d, height: c } = yn(u), p = computed(
      () => e.side + (e.align !== "center" ? `-${e.align}` : "")
    ), f = computed(() => typeof e.collisionPadding == "number" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), m = computed(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), C = computed(() => ({
      padding: f.value,
      boundary: m.value.filter(Es),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: m.value.length > 0
    })), _ = Ra(() => [
      offset({
        mainAxis: e.sideOffset + c.value,
        alignmentAxis: e.alignOffset
      }),
      e.avoidCollisions && shift({
        mainAxis: true,
        crossAxis: !!e.prioritizePosition,
        limiter: e.sticky === "partial" ? limitShift() : void 0,
        ...C.value
      }),
      !e.prioritizePosition && e.avoidCollisions && flip({
        ...C.value
      }),
      size({
        ...C.value,
        apply: ({ elements: S, rects: K, availableWidth: z, availableHeight: k }) => {
          const { width: j, height: ee } = K.reference, ie = S.floating.style;
          Object.assign(S.floating.style, {
            maxWidth: `${z}px`,
            maxHeight: `${k}px`
          }), ie.setProperty(
            "--radix-popper-available-width",
            `${z}px`
          ), ie.setProperty(
            "--radix-popper-available-height",
            `${k}px`
          ), ie.setProperty(
            "--radix-popper-anchor-width",
            `${j}px`
          ), ie.setProperty(
            "--radix-popper-anchor-height",
            `${ee}px`
          );
        }
      }),
      u.value && arrow2({ element: u.value, padding: e.arrowPadding }),
      xs({
        arrowWidth: d.value,
        arrowHeight: c.value
      }),
      e.hideWhenDetached && hide({ strategy: "referenceHidden", ...C.value })
    ]), { floatingStyles: $, placement: E, isPositioned: w, middlewareData: P } = useFloating(
      n.anchor,
      l,
      {
        strategy: "fixed",
        placement: p,
        whileElementsMounted: (...S) => autoUpdate(...S, {
          animationFrame: e.updatePositionStrategy === "always"
        }),
        middleware: _
      }
    ), B = computed(
      () => Qt(E.value)[0]
    ), I = computed(
      () => Qt(E.value)[1]
    );
    watchEffect(() => {
      var S;
      w.value && ((S = e.onPlaced) == null || S.call(e));
    });
    const A = computed(
      () => {
        var S;
        return ((S = P.value.arrow) == null ? void 0 : S.centerOffset) !== 0;
      }
    ), W = ref("");
    watchEffect(() => {
      r.value && (W.value = window.getComputedStyle(r.value).zIndex);
    });
    const F = computed(() => {
      var S;
      return ((S = P.value.arrow) == null ? void 0 : S.x) ?? 0;
    }), N = computed(() => {
      var S;
      return ((S = P.value.arrow) == null ? void 0 : S.y) ?? 0;
    });
    return Ps({
      placedSide: B,
      onArrowChange: (S) => u.value = S,
      arrowX: F,
      arrowY: N,
      shouldHideArrow: A
    }), t({
      $el: r
    }), (S, K) => {
      var z, k, j;
      return openBlock(), createElementBlock("div", {
        ref_key: "floatingRef",
        ref: l,
        "data-radix-popper-content-wrapper": "",
        style: normalizeStyle({
          ...unref($),
          transform: unref(w) ? unref($).transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: W.value,
          "--radix-popper-transform-origin": [
            (z = unref(P).transformOrigin) == null ? void 0 : z.x,
            (k = unref(P).transformOrigin) == null ? void 0 : k.y
          ].join(" ")
        })
      }, [
        createVNode(unref(D), mergeProps({
          ref: (ee) => {
            unref(s)(ee), i.value = ee;
          }
        }, S.$attrs, {
          "as-child": e.asChild,
          as: S.as,
          "data-side": B.value,
          "data-align": I.value,
          style: {
            // if the PopperContent hasn't been placed yet (not all measurements done)
            // we prevent animations so that users's animation don't kick in too early referring wrong sides
            animation: unref(w) ? void 0 : "none",
            // hide the content if using the hide middleware and should be hidden
            opacity: (j = unref(P).hide) != null && j.referenceHidden ? 0 : void 0
          }
        }), {
          default: withCtx(() => [
            renderSlot(S.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-side", "data-align", "style"])
      ], 4);
    };
  }
});
var Bs = createBaseVNode("polygon", { points: "0,0 30,0 15,10" }, null, -1);
var Ss = defineComponent({
  __name: "Arrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(o) {
    const t = o, { primitiveElement: e } = V();
    return (n, s) => (openBlock(), createBlock(unref(D), mergeProps({
      ref_key: "primitiveElement",
      ref: e
    }, t, {
      width: n.width,
      height: n.height,
      viewBox: n.asChild ? void 0 : "0 0 30 10",
      preserveAspectRatio: n.asChild ? void 0 : "none"
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default", {}, () => [
          Bs
        ])
      ]),
      _: 3
    }, 16, ["width", "height", "viewBox", "preserveAspectRatio"]));
  }
});
var Ts = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var Ue = defineComponent({
  inheritAttrs: false,
  __name: "PopperArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(o) {
    const t = $s(), e = computed(() => Ts[t.placedSide.value]);
    return (n, s) => {
      var i, r, l, u;
      return openBlock(), createElementBlock("span", {
        ref: (d) => {
          unref(t).onArrowChange(d);
        },
        style: normalizeStyle({
          position: "absolute",
          left: (i = unref(t).arrowX) != null && i.value ? `${(r = unref(t).arrowX) == null ? void 0 : r.value}px` : void 0,
          top: (l = unref(t).arrowY) != null && l.value ? `${(u = unref(t).arrowY) == null ? void 0 : u.value}px` : void 0,
          [e.value]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[unref(t).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[unref(t).placedSide.value],
          visibility: unref(t).shouldHideArrow.value ? "hidden" : void 0
        })
      }, [
        createVNode(Ss, mergeProps(n.$attrs, {
          style: {
            display: "block"
          },
          as: n.as,
          "as-child": n.asChild,
          width: n.width,
          height: n.height
        }), {
          default: withCtx(() => [
            renderSlot(n.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "width", "height"])
      ], 4);
    };
  }
});
var Ge = defineComponent({
  __name: "VisuallyHidden",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    return (t, e) => (openBlock(), createBlock(unref(D), {
      as: t.as,
      "as-child": t.asChild,
      style: normalizeStyle({
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: "1px",
        display: "inline-block",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      })
    }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "style"]));
  }
});
var Os = defineComponent({
  __name: "VisuallyHiddenInput",
  props: {
    name: {},
    value: {}
  },
  setup(o) {
    const t = o, e = computed(() => typeof t.value == "string" || typeof t.value == "number" ? [{ name: t.name, value: t.value }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((n, s) => Object.entries(n).map(([i, r]) => ({ name: `[${s}][${t.name}][${i}]`, value: r }))) : typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([n, s]) => ({ name: `[${t.name}][${n}]`, value: s })) : []);
    return (n, s) => (openBlock(true), createElementBlock(Fragment, null, renderList(e.value, (i) => (openBlock(), createBlock(Ge, {
      key: i.name,
      as: "input",
      type: "hidden",
      hidden: "",
      readonly: "",
      name: i.name,
      value: i.value
    }, null, 8, ["name", "value"]))), 128));
  }
});
var [we, Ds] = H("ComboboxRoot");
var Fl = defineComponent({
  __name: "ComboboxRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    searchTerm: {},
    multiple: { type: Boolean },
    disabled: { type: Boolean },
    name: {},
    dir: {},
    filterFunction: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:open", "update:searchTerm"],
  setup(o, { emit: t }) {
    const e = o, n = t, { multiple: s, disabled: i, name: r, dir: l } = toRefs(e), u = pe(l), d = X(e, "searchTerm", n, {
      defaultValue: "",
      passive: e.searchTerm === void 0
    }), c = X(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? s.value ? [] : void 0,
      passive: e.modelValue === void 0,
      deep: true
    }), p = X(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    async function f(k) {
      var j;
      p.value = k, await nextTick(), k && p.value === k && ((j = $.value) == null || j.focus()), k || (C.value = false), z();
    }
    function m(k) {
      if (s.value && Array.isArray(c.value)) {
        const j = c.value.findIndex((ee) => toRaw(ee) === k);
        j === -1 ? c.value.push(k) : c.value.splice(j, 1);
      } else
        c.value = k, f(false);
    }
    const C = ref(false), _ = ref(/* @__PURE__ */ new Set()), $ = ref(), E = ref(), { primitiveElement: w, currentElement: P } = V(), { createCollection: B } = ne(void 0, "data-radix-vue-combobox-item"), I = B(E), A = ref(), W = computed(() => Array.from(_.value).sort((j, ee) => I.value.indexOf(j.vnode.el) - I.value.indexOf(ee.vnode.el)).map((j) => j.props.value)), F = computed(() => {
      if (C.value) {
        if (e.filterFunction)
          return e.filterFunction(W.value, d.value);
        if (typeof W.value[0] == "string")
          return W.value.filter((k) => {
            var j;
            return k.toLowerCase().includes((j = d.value) == null ? void 0 : j.toLowerCase());
          });
      }
      return W.value;
    }), N = computed(() => F.value.findIndex((k) => toRaw(k) === toRaw(A.value))), S = computed(() => {
      var k;
      return (k = Array.from(_.value).find((j) => toRaw(j.props.value) === toRaw(A.value))) == null ? void 0 : k.vnode.el;
    });
    watch(() => F.value.length, (k) => {
      k && N.value === -1 && (A.value = F.value[0]);
    }), watch(c, async (k) => {
      await nextTick(), A.value = k, typeof k == "string" && !s.value ? d.value = k : d.value = "";
    }, { immediate: true }), watch(p, (k) => {
      k && c.value && (typeof c.value == "string" && !s.value ? A.value = c.value : Array.isArray(c.value) && s.value && (A.value = c.value[0]));
    });
    const K = ze(P);
    function z() {
      S.value instanceof Element && S.value.scrollIntoView({ block: "nearest" });
    }
    return Ds({
      searchTerm: d,
      modelValue: c,
      onValueChange: m,
      isUserInputted: C,
      multiple: s,
      disabled: i,
      open: p,
      onOpenChange: f,
      options: W,
      optionsInstance: _,
      filteredOptions: F,
      contentId: te(),
      inputElement: $,
      onInputElementChange: (k) => $.value = k,
      onInputNavigation: async (k) => {
        const j = N.value;
        j === 0 && k === "up" || j === F.value.length - 1 && k === "down" || (j === -1 && F.value.length || k === "home" ? A.value = F.value[0] : k === "end" ? A.value = F.value[F.value.length - 1] : A.value = F.value[k === "up" ? j - 1 : j + 1], z());
      },
      onInputEnter: async () => {
        var k;
        A.value && S.value instanceof Element && ((k = S.value) == null || k.click());
      },
      selectedValue: A,
      onSelectedValueChange: (k) => A.value = k,
      parentElement: P,
      contentElement: E,
      onContentElementChange: (k) => E.value = k
    }), (k, j) => (openBlock(), createBlock(unref(Fe), null, {
      default: withCtx(() => [
        createVNode(unref(D), mergeProps({
          ref_key: "primitiveElement",
          ref: w,
          style: {
            pointerEvents: unref(p) ? "auto" : void 0
          },
          as: k.as,
          "as-child": k.asChild
        }, k.$attrs, { dir: unref(u) }), {
          default: withCtx(() => [
            renderSlot(k.$slots, "default", {
              activeIndex: N.value,
              open: unref(p),
              disabled: unref(i),
              value: unref(c)
            }),
            unref(K) && unref(r) ? (openBlock(), createBlock(unref(Os), {
              key: 0,
              name: unref(r),
              value: unref(c)
            }, null, 8, ["name", "value"])) : createCommentVNode("", true)
          ]),
          _: 3
        }, 16, ["style", "as", "as-child", "dir"])
      ]),
      _: 3
    }));
  }
});
var As = ["type", "aria-expanded", "aria-controls", "disabled", "aria-disabled", "onKeydown"];
var Vl = defineComponent({
  __name: "ComboboxInput",
  props: {
    type: { default: "text" },
    disabled: { type: Boolean },
    autoFocus: { type: Boolean }
  },
  setup(o) {
    const t = o, e = we(), n = ref();
    onMounted(() => {
      n.value && (e.inputElement = n, e.onInputElementChange(n.value), setTimeout(() => {
        var u;
        t.autoFocus && ((u = n.value) == null || u.focus());
      }, 1));
    });
    const s = computed(() => t.disabled || e.disabled.value || false);
    function i(u) {
      e.open.value ? e.onInputNavigation(u.key === "ArrowUp" ? "up" : "down") : e.onOpenChange(true);
    }
    function r(u) {
      e.open.value && e.onInputNavigation(u.key === "Home" ? "home" : "end");
    }
    function l() {
      e.open.value || e.onOpenChange(true), e.isUserInputted.value = true;
    }
    return (u, d) => withDirectives((openBlock(), createElementBlock("input", {
      ref_key: "elRef",
      ref: n,
      "onUpdate:modelValue": d[0] || (d[0] = (c) => unref(e).searchTerm.value = c),
      type: u.type,
      "aria-expanded": unref(e).open.value,
      "aria-controls": unref(e).contentId,
      disabled: s.value,
      "aria-disabled": s.value ?? void 0,
      "aria-autocomplete": "list",
      tabindex: "0",
      role: "combobox",
      autocomplete: "false",
      onInput: l,
      onKeydown: [
        withKeys(withModifiers(i, ["prevent"]), ["down", "up"]),
        d[1] || (d[1] = withKeys(
          //@ts-ignore
          (...c) => unref(e).onInputEnter && unref(e).onInputEnter(...c),
          ["enter"]
        )),
        withKeys(withModifiers(r, ["prevent"]), ["home", "end"])
      ]
    }, null, 40, As)), [
      [vModelDynamic, unref(e).searchTerm.value]
    ]);
  }
});
var Ll = defineComponent({
  __name: "ComboboxAnchor",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    return (t, e) => (openBlock(), createBlock(unref(Ve), { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(D), mergeProps({
          "as-child": t.asChild,
          as: t.as
        }, t.$attrs), {
          default: withCtx(() => [
            renderSlot(t.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as"])
      ]),
      _: 3
    }));
  }
});
var Kl = defineComponent({
  __name: "ComboboxTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = we(), n = computed(() => t.disabled || e.disabled.value || false);
    return (s, i) => (openBlock(), createBlock(unref(D), mergeProps({
      type: s.as === "button" ? "button" : void 0
    }, t, {
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": unref(e).open.value,
      "aria-controls": unref(e).contentId,
      "data-state": unref(e).open.value ? "open" : "closed",
      disabled: n.value,
      "data-disabled": n.value,
      "aria-disabled": n.value ?? void 0,
      onClick: i[0] || (i[0] = (r) => unref(e).onOpenChange(!unref(e).open.value))
    }), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "disabled", "data-disabled", "aria-disabled"]));
  }
});
var Nl = defineComponent({
  __name: "ComboboxCancel",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = we();
    function n() {
      var s;
      e.searchTerm.value = "", (s = e.inputElement.value) == null || s.focus();
    }
    return (s, i) => (openBlock(), createBlock(unref(D), mergeProps({
      type: s.as === "button" ? "button" : void 0
    }, t, {
      tabindex: "-1",
      onClick: n
    }), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
});
var [xn, Is] = H("ComboboxGroup");
var Hl = defineComponent({
  __name: "ComboboxGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = te(), n = ref([]), s = we(), i = computed(() => !s.isUserInputted.value || n.value.length === 0 || s.filteredOptions.value.map((r) => JSON.stringify(r)).some((r) => n.value.map((l) => JSON.stringify(l)).includes(r)));
    return Is({
      id: e,
      options: n
    }), (r, l) => withDirectives((openBlock(), createBlock(unref(D), mergeProps({ role: "group" }, t, { "aria-labelledby": unref(e) }), {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"])), [
      [vShow, i.value]
    ]);
  }
});
var Wl = defineComponent({
  __name: "ComboboxLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(o) {
    const t = o, e = xn({ id: "" });
    return (n, s) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      id: unref(e).id
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
});
var Ms = "dismissableLayer.pointerDownOutside";
var ks = "dismissableLayer.focusOutside";
function $n(o, t) {
  const e = t.closest(
    "[data-dismissable-layer]"
  ), n = o.querySelector(
    "[data-dismissable-layer]"
  ), s = Array.from(
    o.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  return !!(e && n === e || s.indexOf(n) < s.indexOf(e));
}
function Rs(o, t) {
  var i;
  const e = ((i = t == null ? void 0 : t.value) == null ? void 0 : i.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = ref(false), s = ref(() => {
  });
  return watchEffect((r) => {
    if (!Pe)
      return;
    const l = async (d) => {
      if (t != null && t.value) {
        if ($n(t.value, d.target)) {
          n.value = false;
          return;
        }
        if (d.target && !n.value) {
          let c = function() {
            uo(
              Ms,
              o,
              p
            );
          };
          const p = { originalEvent: d };
          d.pointerType === "touch" ? (e.removeEventListener("click", s.value), s.value = c, e.addEventListener("click", s.value, {
            once: true
          })) : c();
        } else
          e.removeEventListener("click", s.value);
        n.value = false;
      }
    }, u = window.setTimeout(() => {
      e.addEventListener("pointerdown", l);
    }, 0);
    r(() => {
      window.clearTimeout(u), e.removeEventListener("pointerdown", l), e.removeEventListener("click", s.value);
    });
  }), {
    onPointerDownCapture: () => n.value = true
  };
}
function Fs(o, t) {
  var s;
  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = ref(false);
  return watchEffect((i) => {
    if (!Pe)
      return;
    const r = async (l) => {
      t != null && t.value && (await nextTick(), !$n(t.value, l.target) && l.target && !n.value && uo(
        ks,
        o,
        { originalEvent: l }
      ));
    };
    e.addEventListener("focusin", r), i(() => e.removeEventListener("focusin", r));
  }), {
    onFocusCapture: () => n.value = true,
    onBlurCapture: () => n.value = false
  };
}
var he = reactive({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var Be = defineComponent({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, { primitiveElement: s, currentElement: i } = V(), r = computed(
      () => {
        var C;
        return ((C = i.value) == null ? void 0 : C.ownerDocument) ?? globalThis.document;
      }
    ), l = computed(() => he.layersRoot), u = computed(() => i.value ? Array.from(l.value).indexOf(i.value) : -1), d = computed(() => he.layersWithOutsidePointerEventsDisabled.size > 0), c = computed(() => {
      const C = Array.from(l.value), [_] = [...he.layersWithOutsidePointerEventsDisabled].slice(-1), $ = C.indexOf(_);
      return u.value >= $;
    }), p = Rs(async (C) => {
      const _ = [...he.branches].some(
        ($) => $.contains(C.target)
      );
      !c.value || _ || (n("pointerDownOutside", C), n("interactOutside", C), await nextTick(), C.defaultPrevented || n("dismiss"));
    }, i), f = Fs((C) => {
      [...he.branches].some(
        ($) => $.contains(C.target)
      ) || (n("focusOutside", C), n("interactOutside", C), C.defaultPrevented || n("dismiss"));
    }, i);
    vo("Escape", (C) => {
      u.value === l.value.size - 1 && (n("escapeKeyDown", C), C.defaultPrevented || n("dismiss"));
    });
    let m;
    return watchEffect((C) => {
      i.value && (e.disableOutsidePointerEvents && (he.layersWithOutsidePointerEventsDisabled.size === 0 && (m = r.value.body.style.pointerEvents, r.value.body.style.pointerEvents = "none"), he.layersWithOutsidePointerEventsDisabled.add(i.value)), l.value.add(i.value), C(() => {
        e.disableOutsidePointerEvents && he.layersWithOutsidePointerEventsDisabled.size === 1 && (r.value.body.style.pointerEvents = m);
      }));
    }), watchEffect((C) => {
      C(() => {
        i.value && (l.value.delete(i.value), he.layersWithOutsidePointerEventsDisabled.delete(i.value));
      });
    }), (C, _) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: s,
      "as-child": C.asChild,
      as: C.as,
      "data-dismissable-layer": "",
      style: normalizeStyle({
        pointerEvents: d.value ? c.value ? "auto" : "none" : void 0
      }),
      onFocusCapture: unref(f).onFocusCapture,
      onBlurCapture: unref(f).onBlurCapture,
      onPointerdownCapture: unref(p).onPointerDownCapture
    }, {
      default: withCtx(() => [
        renderSlot(C.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]));
  }
});
var Vs = defineComponent({
  __name: "DismissableLayerBranch",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = V();
    return onMounted(() => {
      he.branches.add(n.value);
    }), onUnmounted(() => {
      he.branches.delete(n.value);
    }), (s, i) => (openBlock(), createBlock(unref(D), mergeProps({
      ref_key: "primitiveElement",
      ref: e
    }, t), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Ls, Ks] = H("ComboboxContent");
var Ns = defineComponent({
  __name: "ComboboxContentImpl",
  props: {
    position: { default: "inline" },
    bodyLock: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, { position: s } = toRefs(e), i = we();
    it(e.bodyLock);
    const { primitiveElement: r, currentElement: l } = V();
    rt(l);
    const u = computed(() => e.position === "popper" ? e : {});
    function d(p) {
      i.onSelectedValueChange("");
    }
    onMounted(() => {
      i.onContentElementChange(l.value);
    });
    const c = {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-combobox-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-combobox-content-available-width": "var(--radix-popper-available-width)",
      "--radix-combobox-content-available-height": "var(--radix-popper-available-height)",
      "--radix-combobox-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-combobox-trigger-height": "var(--radix-popper-anchor-height)"
    };
    return Ks({ position: s }), (p, f) => (openBlock(), createBlock(unref(Be), {
      "as-child": "",
      "disable-outside-pointer-events": p.disableOutsidePointerEvents,
      onDismiss: f[0] || (f[0] = (m) => unref(i).onOpenChange(false)),
      onFocusOutside: f[1] || (f[1] = (m) => {
        var C;
        (C = unref(i).parentElement.value) != null && C.contains(m.target) && m.preventDefault(), n("focusOutside", m);
      }),
      onInteractOutside: f[2] || (f[2] = (m) => n("interactOutside", m)),
      onEscapeKeyDown: f[3] || (f[3] = (m) => n("escapeKeyDown", m)),
      onPointerDownOutside: f[4] || (f[4] = (m) => {
        var C;
        (C = unref(i).parentElement.value) != null && C.contains(m.target) && m.preventDefault(), n("pointerDownOutside", m);
      })
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(unref(s) === "popper" ? unref(je) : unref(D)), mergeProps({ ...p.$attrs, ...u.value }, {
          id: unref(i).contentId,
          ref_key: "primitiveElement",
          ref: r,
          role: "listbox",
          "data-state": unref(i).open.value ? "open" : "closed",
          style: {
            // flex layout so we can place the scroll buttons properly
            display: "flex",
            flexDirection: "column",
            // reset the outline by default as the content MAY get focused
            outline: "none",
            ...unref(s) === "popper" ? c : {}
          },
          onPointerleave: d
        }), {
          default: withCtx(() => [
            renderSlot(p.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "data-state", "style"]))
      ]),
      _: 3
    }, 8, ["disable-outside-pointer-events"]));
  }
});
var zl = defineComponent({
  __name: "ComboboxContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const s = ue(o, t), i = we();
    return (r, l) => (openBlock(), createBlock(unref(ae), {
      present: r.forceMount || unref(i).open.value
    }, {
      default: withCtx(() => [
        createVNode(Ns, normalizeProps(guardReactiveProps({ ...unref(s), ...r.$attrs })), {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var jl = defineComponent({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = we(), n = computed(() => e.searchTerm.value && e.filteredOptions.value.length === 0);
    return (s, i) => n.value ? (openBlock(), createBlock(unref(D), normalizeProps(mergeProps({ key: 0 }, t)), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default", {}, () => [
          createTextVNode("No options")
        ])
      ]),
      _: 3
    }, 16)) : createCommentVNode("", true);
  }
});
var Ul = defineComponent({
  __name: "ComboboxViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(D), { as: "style" }, {
        default: withCtx(() => [
          createTextVNode(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-combobox-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      }),
      createVNode(unref(D), mergeProps({
        "data-radix-combobox-viewport": "",
        role: "presentation"
      }, { ...e.$attrs, ...t }, { style: {
        // we use position: 'relative' here on the `viewport` so that when we call
        // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
        // (independent of the scrollUpButton).
        position: "relative",
        flex: 1,
        overflow: "auto"
      } }), {
        default: withCtx(() => [
          renderSlot(e.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])
    ], 64));
  }
});
var [Hs, Ws] = H("ComboboxItem");
var zs = "combobox.select";
var Gl = defineComponent({
  __name: "ComboboxItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t, { disabled: s } = toRefs(e), i = we(), r = xn({ id: "", options: ref([]) }), { primitiveElement: l, currentElement: u } = V(), d = computed(
      () => {
        var w, P;
        return i.multiple.value && Array.isArray(i.modelValue.value) ? (w = i.modelValue.value) == null ? void 0 : w.includes(e.value) : JSON.stringify((P = i.modelValue) == null ? void 0 : P.value) === JSON.stringify(e.value);
      }
    ), c = computed(() => JSON.stringify(i.selectedValue.value) === JSON.stringify(e.value)), p = ref(e.textValue ?? ""), f = te(), m = computed(() => i.isUserInputted.value ? i.searchTerm.value === "" || i.filteredOptions.value.map((w) => JSON.stringify(w)).includes(JSON.stringify(e.value)) : true);
    async function C(w) {
      n("select", w), !(w != null && w.defaultPrevented) && !s.value && w && i.onValueChange(e.value);
    }
    function _(w) {
      if (!w)
        return;
      const P = { originalEvent: w, value: e.value };
      uo(zs, C, P);
    }
    async function $(w) {
      await nextTick(), !w.defaultPrevented && i.onSelectedValueChange(e.value);
    }
    if (e.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    const E = getCurrentInstance();
    return onMounted(() => {
      var w, P, B, I;
      E && i.optionsInstance.value.add(E), (P = (w = r.options) == null ? void 0 : w.value) != null && P.includes(e.value) || (B = r.options) == null || B.value.push(e.value), !p.value && ((I = u.value) != null && I.textContent) && (p.value = u.value.textContent);
    }), onUnmounted(() => {
      E && i.optionsInstance.value.delete(E);
    }), Ws({
      isSelected: d
    }), (w, P) => m.value ? (openBlock(), createBlock(unref(D), {
      key: 0,
      ref_key: "primitiveElement",
      ref: l,
      role: "option",
      tabindex: "-1",
      "data-radix-vue-combobox-item": "",
      "aria-labelledby": unref(f),
      "data-highlighted": c.value ? "" : void 0,
      "aria-selected": d.value,
      "data-state": d.value ? "checked" : "unchecked",
      "aria-disabled": unref(s) || void 0,
      "data-disabled": unref(s) ? "" : void 0,
      as: w.as,
      "as-child": w.asChild,
      onClick: _,
      onPointermove: $
    }, {
      default: withCtx(() => [
        renderSlot(w.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(w.value), 1)
        ])
      ]),
      _: 3
    }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "as", "as-child"])) : createCommentVNode("", true);
  }
});
var ql = defineComponent({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = Hs();
    return (n, s) => unref(e).isSelected.value ? (openBlock(), createBlock(unref(D), mergeProps({
      key: 0,
      "aria-hidden": ""
    }, t), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16)) : createCommentVNode("", true);
  }
});
var Yl = defineComponent({
  __name: "ComboboxSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(D), mergeProps({ "aria-hidden": "" }, t), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Xl = defineComponent({
  __name: "ComboboxArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = we(), n = Ls();
    return (s, i) => unref(e).open.value && unref(n).position.value === "popper" ? (openBlock(), createBlock(unref(Ue), normalizeProps(mergeProps({ key: 0 }, t)), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16)) : createCommentVNode("", true);
  }
});
var Se = defineComponent({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = Pt();
    return (e, n) => unref(t) || e.forceMount ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: e.to,
      disabled: e.disabled
    }, [
      renderSlot(e.$slots, "default")
    ], 8, ["to", "disabled"])) : createCommentVNode("", true);
  }
});
var Jl = defineComponent({
  __name: "ComboboxPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Se), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var js = ["name", "disabled", "required", "value", "checked", "data-state", "data-disabled"];
var [Us, Gs] = H("SwitchRoot");
var Zl = defineComponent({
  __name: "SwitchRoot",
  props: {
    defaultChecked: { type: Boolean },
    checked: { type: Boolean, default: void 0 },
    disabled: { type: Boolean },
    required: { type: Boolean },
    name: {},
    id: {},
    value: { default: "on" },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(o, { emit: t }) {
    const e = o, n = t, { disabled: s } = toRefs(e), i = X(e, "checked", n, {
      defaultValue: e.defaultChecked,
      passive: e.checked === void 0
    });
    function r() {
      s.value || (i.value = !i.value);
    }
    const { primitiveElement: l, currentElement: u } = V(), d = ze(u), c = computed(() => {
      var p;
      return e.id && u.value ? (p = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : p.innerText : void 0;
    });
    return Gs({
      checked: i,
      toggleCheck: r,
      disabled: s
    }), (p, f) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(D), mergeProps(p.$attrs, {
        id: p.id,
        ref_key: "primitiveElement",
        ref: l,
        role: "switch",
        type: p.as === "button" ? "button" : void 0,
        value: p.value,
        "aria-label": p.$attrs["aria-label"] || c.value,
        "aria-checked": unref(i),
        "aria-required": p.required,
        "data-state": unref(i) ? "checked" : "unchecked",
        "data-disabled": unref(s) ? "" : void 0,
        "as-child": p.asChild,
        as: p.as,
        disabled: unref(s),
        onClick: r,
        onKeydown: withKeys(withModifiers(r, ["prevent"]), ["enter"])
      }), {
        default: withCtx(() => [
          renderSlot(p.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "type", "value", "aria-label", "aria-checked", "aria-required", "data-state", "data-disabled", "as-child", "as", "disabled", "onKeydown"]),
      unref(d) ? (openBlock(), createElementBlock("input", {
        key: 0,
        type: "checkbox",
        name: p.name,
        tabindex: "-1",
        "aria-hidden": "",
        disabled: unref(s),
        required: p.required,
        value: p.value,
        checked: !!unref(i),
        "data-state": unref(i) ? "checked" : "unchecked",
        "data-disabled": unref(s) ? "" : void 0,
        style: normalizeStyle({
          transform: "translateX(-100%)",
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        })
      }, null, 12, js)) : createCommentVNode("", true)
    ], 64));
  }
});
var Ql = defineComponent({
  __name: "SwitchThumb",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = Us();
    return (e, n) => {
      var s;
      return openBlock(), createBlock(unref(D), {
        "data-state": (s = unref(t).checked) != null && s.value ? "checked" : "unchecked",
        "data-disabled": unref(t).disabled.value ? "" : void 0,
        "as-child": e.asChild,
        as: e.as
      }, {
        default: withCtx(() => [
          renderSlot(e.$slots, "default")
        ]),
        _: 3
      }, 8, ["data-state", "data-disabled", "as-child", "as"]);
    };
  }
});
var Pn = defineComponent({
  __name: "BaseSeparator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = ["horizontal", "vertical"];
    function n(l) {
      return e.includes(l);
    }
    const s = computed(
      () => n(t.orientation) ? t.orientation : "horizontal"
    ), i = computed(
      () => s.value === "vertical" ? t.orientation : void 0
    ), r = computed(
      () => t.decorative ? { role: "none" } : { "aria-orientation": i.value, role: "separator" }
    );
    return (l, u) => (openBlock(), createBlock(unref(D), mergeProps({
      as: l.as,
      "as-child": l.asChild,
      "data-orientation": s.value
    }, r.value), {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "data-orientation"]));
  }
});
var eu = defineComponent({
  __name: "Separator",
  props: {
    orientation: { default: "horizontal" },
    decorative: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(Pn, normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var tu = defineComponent({
  __name: "Label",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "label" }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      onMousedown: n[0] || (n[0] = (s) => {
        !s.defaultPrevented && s.detail > 1 && s.preventDefault();
      })
    }), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var qs = defineComponent({
  __name: "ToggleRoot",
  props: {
    defaultValue: { type: Boolean },
    pressed: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:pressed"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "pressed", t, {
      defaultValue: e.defaultValue,
      passive: e.pressed === void 0
    });
    function i() {
      s.value = !s.value;
    }
    const r = computed(() => s.value ? "on" : "off");
    return (l, u) => (openBlock(), createBlock(unref(D), {
      type: l.as === "button" ? "button" : void 0,
      "as-child": e.asChild,
      as: l.as,
      "aria-pressed": unref(s),
      "data-state": r.value,
      "data-disabled": l.disabled ? "" : void 0,
      disabled: l.disabled,
      onClick: i,
      onKeydown: withKeys(i, ["enter"])
    }, {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "as-child", "as", "aria-pressed", "data-state", "data-disabled", "disabled", "onKeydown"]));
  }
});
var Ys = "rovingFocusGroup.onEntryFocus";
var Xs = { bubbles: false, cancelable: true };
var Js = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Zs(o, t) {
  return t !== "rtl" ? o : o === "ArrowLeft" ? "ArrowRight" : o === "ArrowRight" ? "ArrowLeft" : o;
}
function Qs(o, t, e) {
  const n = Zs(o.key, e);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return Js[n];
}
function Bn(o) {
  const t = document.activeElement;
  for (const e of o)
    if (e === t || (e.focus(), document.activeElement !== t))
      return;
}
function ei(o, t) {
  return o.map((e, n) => o[(t + n) % o.length]);
}
var [ti, oi] = H("RovingFocusGroup");
var qe = defineComponent({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: false },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(o, { emit: t }) {
    const e = o, n = t, { loop: s, orientation: i, dir: r } = toRefs(e), l = pe(r), u = X(e, "currentTabStopId", n, {
      defaultValue: e.defaultCurrentTabStopId,
      passive: e.currentTabStopId === void 0
    }), d = ref(false), c = ref(false), p = ref(0), { primitiveElement: f, currentElement: m } = V(), { createCollection: C } = ne("rovingFocus"), _ = C(m);
    function $(E) {
      const w = !c.value;
      if (E.currentTarget && E.target === E.currentTarget && w && !d.value) {
        const P = new CustomEvent(Ys, Xs);
        if (E.currentTarget.dispatchEvent(P), n("entryFocus", P), !P.defaultPrevented) {
          const B = _.value, I = B.find((F) => F.getAttribute("data-active") === "true"), A = B.find(
            (F) => F.id === u.value
          ), W = [I, A, ...B].filter(
            Boolean
          );
          Bn(W);
        }
      }
      c.value = false;
    }
    return oi({
      loop: s,
      dir: l,
      orientation: i,
      currentTabStopId: u,
      onItemFocus: (E) => {
        u.value = E;
      },
      onItemShiftTab: () => {
        d.value = true;
      },
      onFocusableItemAdd: () => {
        p.value++;
      },
      onFocusableItemRemove: () => {
        p.value--;
      }
    }), (E, w) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: f,
      tabindex: d.value || p.value === 0 ? -1 : 0,
      "data-orientation": unref(i),
      as: E.as,
      "as-child": E.asChild,
      style: { outline: "none" },
      onMousedown: w[0] || (w[0] = (P) => c.value = true),
      onFocus: $,
      onBlur: w[1] || (w[1] = (P) => d.value = false)
    }, {
      default: withCtx(() => [
        renderSlot(E.$slots, "default")
      ]),
      _: 3
    }, 8, ["tabindex", "data-orientation", "as", "as-child"]));
  }
});
var Ye = defineComponent({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: true },
    active: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = ti(), n = te(), s = computed(() => t.tabStopId || n), i = computed(
      () => e.currentTabStopId.value === s.value
    ), { injectCollection: r } = ne("rovingFocus"), l = r();
    onMounted(() => {
      t.focusable && e.onFocusableItemAdd();
    }), onUnmounted(() => {
      t.focusable && e.onFocusableItemRemove();
    });
    function u(d) {
      if (d.key === "Tab" && d.shiftKey) {
        e.onItemShiftTab();
        return;
      }
      if (d.target !== d.currentTarget)
        return;
      const c = Qs(
        d,
        e.orientation.value,
        e.dir.value
      );
      if (c !== void 0) {
        d.preventDefault();
        let p = [...l.value];
        if (c === "last")
          p.reverse();
        else if (c === "prev" || c === "next") {
          c === "prev" && p.reverse();
          const f = p.indexOf(
            d.currentTarget
          );
          p = e.loop.value ? ei(p, f + 1) : p.slice(f + 1);
        }
        nextTick(() => Bn(p));
      }
    }
    return (d, c) => (openBlock(), createBlock(unref(D), {
      "data-radix-vue-collection-item": "",
      tabindex: i.value ? 0 : -1,
      "data-orientation": unref(e).orientation.value,
      "data-active": d.active,
      "data-disabled": !d.focusable || void 0,
      as: d.as,
      "as-child": d.asChild,
      onMousedown: c[0] || (c[0] = (p) => {
        d.focusable ? unref(e).onItemFocus(s.value) : p.preventDefault();
      }),
      onFocus: c[1] || (c[1] = (p) => unref(e).onItemFocus(s.value)),
      onKeydown: u
    }, {
      default: withCtx(() => [
        renderSlot(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"]));
  }
});
var [ni, ai] = H("ToggleGroupRoot");
var si = defineComponent({
  __name: "ToggleGroupRoot",
  props: {
    type: { default: "single" },
    defaultValue: {},
    modelValue: {},
    rovingFocus: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    orientation: { default: "horizontal" },
    dir: {},
    loop: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, n = t, { loop: s, rovingFocus: i, disabled: r, dir: l } = toRefs(e), u = pe(l), { modelValue: d, changeModelValue: c } = Cn(e, n);
    return ai({
      type: e.type,
      modelValue: d,
      changeModelValue: c,
      dir: u,
      orientation: e.orientation,
      loop: s,
      rovingFocus: i,
      disabled: r
    }), (p, f) => (openBlock(), createBlock(resolveDynamicComponent(unref(i) ? unref(qe) : unref(D)), {
      "as-child": "",
      orientation: unref(i) ? p.orientation : void 0,
      dir: unref(u),
      loop: unref(i) ? unref(s) : void 0
    }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          role: "group",
          "as-child": p.asChild,
          as: p.as
        }, {
          default: withCtx(() => [
            renderSlot(p.$slots, "default", { modelValue: unref(d) })
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
});
var ii = defineComponent({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = ni(), n = computed(() => {
      var i;
      return ((i = e.disabled) == null ? void 0 : i.value) || t.disabled;
    }), s = computed(() => {
      var i;
      return (i = e.modelValue.value) == null ? void 0 : i.includes(t.value);
    });
    return (i, r) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).rovingFocus.value ? unref(Ye) : unref(D)), {
      "as-child": "",
      focusable: !n.value,
      active: s.value
    }, {
      default: withCtx(() => {
        var l;
        return [
          createVNode(unref(qs), mergeProps(t, {
            disabled: n.value,
            pressed: unref(e).type === "single" ? unref(e).modelValue.value === i.value : (l = unref(e).modelValue.value) == null ? void 0 : l.includes(i.value),
            "onUpdate:pressed": r[0] || (r[0] = (u) => unref(e).changeModelValue(i.value))
          }), {
            default: withCtx(() => [
              renderSlot(i.$slots, "default")
            ]),
            _: 3
          }, 16, ["disabled", "pressed"])
        ];
      }),
      _: 3
    }, 8, ["focusable", "active"]));
  }
});
var ou = defineComponent({
  inheritAttrs: false,
  __name: "AspectRatio",
  props: {
    ratio: { default: 1 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = computed(() => 1 / t.ratio * 100);
    return (n, s) => (openBlock(), createElementBlock("div", {
      style: normalizeStyle(`position: relative; width: 100%; padding-bottom: ${e.value}%`),
      "data-radix-aspect-ratio-wrapper": ""
    }, [
      createVNode(unref(D), mergeProps({
        "as-child": n.asChild,
        as: n.as,
        style: { position: "absolute", inset: "0px" }
      }, n.$attrs), {
        default: withCtx(() => [
          renderSlot(n.$slots, "default", { aspect: e.value })
        ]),
        _: 3
      }, 16, ["as-child", "as"])
    ], 4));
  }
});
var [Co, ri] = H("TabsRoot");
var nu = defineComponent({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: {},
    activationMode: { default: "automatic" },
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, n = t, { orientation: s, dir: i } = toRefs(e), r = pe(i), l = X(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    });
    return ri({
      modelValue: l,
      changeModelValue: (u) => {
        l.value = u;
      },
      orientation: s,
      dir: r,
      activationMode: e.activationMode,
      baseId: te()
    }), (u, d) => (openBlock(), createBlock(unref(D), {
      dir: unref(r),
      "data-orientation": unref(s),
      "as-child": u.asChild,
      as: u.as
    }, {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir", "data-orientation", "as-child", "as"]));
  }
});
var au = defineComponent({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { loop: e } = toRefs(t), n = Co();
    return (s, i) => (openBlock(), createBlock(unref(qe), {
      "as-child": "",
      orientation: unref(n).orientation.value,
      dir: unref(n).dir.value,
      loop: unref(e)
    }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          role: "tablist",
          "as-child": s.asChild,
          as: s.as,
          "aria-orientation": unref(n).orientation.value
        }, {
          default: withCtx(() => [
            renderSlot(s.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "aria-orientation"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
});
function Sn(o, t) {
  return `${o}-trigger-${t}`;
}
function Tn(o, t) {
  return `${o}-content-${t}`;
}
var su = defineComponent({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Co(), n = computed(() => Sn(e.baseId, t.value)), s = computed(() => Tn(e.baseId, t.value)), i = computed(() => t.value === e.modelValue.value), r = ref(i.value);
    return onMounted(() => {
      requestAnimationFrame(() => {
        r.value = false;
      });
    }), (l, u) => (openBlock(), createBlock(unref(ae), {
      present: i.value,
      "force-mount": ""
    }, {
      default: withCtx(({ present: d }) => [
        createVNode(unref(D), {
          id: s.value,
          "as-child": l.asChild,
          as: l.as,
          role: "tabpanel",
          "data-state": i.value ? "active" : "inactive",
          "data-orientation": unref(e).orientation.value,
          "aria-labelledby": n.value,
          hidden: !d.value,
          tabindex: "0",
          style: normalizeStyle({
            animationDuration: r.value ? "0s" : void 0
          })
        }, {
          default: withCtx(() => [
            l.forceMount || i.value ? renderSlot(l.$slots, "default", { key: 0 }) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1032, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var iu = defineComponent({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Co(), n = computed(() => Sn(e.baseId, t.value)), s = computed(() => Tn(e.baseId, t.value)), i = computed(() => t.value === e.modelValue.value);
    return (r, l) => (openBlock(), createBlock(unref(Ye), {
      "as-child": "",
      focusable: !r.disabled,
      active: i.value
    }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          id: n.value,
          role: "tab",
          type: r.as === "button" ? "button" : void 0,
          as: r.as,
          "as-child": r.asChild,
          "aria-selected": i.value ? "true" : "false",
          "aria-controls": s.value,
          "data-state": i.value ? "active" : "inactive",
          disabled: r.disabled,
          "data-disabled": r.disabled ? "" : void 0,
          "data-orientation": unref(e).orientation.value,
          onMousedown: l[0] || (l[0] = withModifiers((u) => {
            !r.disabled && u.ctrlKey === false ? unref(e).changeModelValue(r.value) : u.preventDefault();
          }, ["left"])),
          onKeydown: l[1] || (l[1] = withKeys((u) => unref(e).changeModelValue(r.value), ["enter", "space"])),
          onFocus: l[2] || (l[2] = () => {
            const u = unref(e).activationMode !== "manual";
            !i.value && !r.disabled && u && unref(e).changeModelValue(r.value);
          })
        }, {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
});
function On(o, [t, e]) {
  return Math.min(e, Math.max(t, o));
}
function li(o = [], t, e) {
  const n = [...o];
  return n[e] = t, n.sort((s, i) => s - i);
}
function Dn(o, t, e) {
  const i = 100 / (e - t) * (o - t);
  return On(i, [0, 100]);
}
function ui(o, t) {
  return t > 2 ? `Value ${o + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][o] : void 0;
}
function di(o, t) {
  if (o.length === 1)
    return 0;
  const e = o.map((s) => Math.abs(s - t)), n = Math.min(...e);
  return e.indexOf(n);
}
function ci(o, t, e) {
  const n = o / 2, i = _o([0, 50], [0, n]);
  return (n - i(t) * e) * e;
}
function pi(o) {
  return o.slice(0, -1).map((t, e) => o[e + 1] - t);
}
function fi(o, t) {
  if (t > 0) {
    const e = pi(o);
    return Math.min(...e) >= t;
  }
  return true;
}
function _o(o, t) {
  return (e) => {
    if (o[0] === o[1] || t[0] === t[1])
      return t[0];
    const n = (t[1] - t[0]) / (o[1] - o[0]);
    return t[0] + n * (e - o[0]);
  };
}
function vi(o) {
  return (String(o).split(".")[1] || "").length;
}
function mi(o, t) {
  const e = 10 ** t;
  return Math.round(o * e) / e;
}
var An = ["PageUp", "PageDown"];
var In = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var Mn = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var [kn, Rn] = H(["SliderVertical", "SliderHorizontal"]);
var Fn = defineComponent({
  __name: "SliderImpl",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  emits: ["slideStart", "slideMove", "slideEnd", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Dt();
    return (i, r) => (openBlock(), createBlock(unref(D), mergeProps({ "data-slider-impl": "" }, e, {
      onKeydown: r[0] || (r[0] = (l) => {
        l.key === "Home" ? (n("homeKeyDown", l), l.preventDefault()) : l.key === "End" ? (n("endKeyDown", l), l.preventDefault()) : unref(An).concat(unref(In)).includes(l.key) && (n("stepKeyDown", l), l.preventDefault());
      }),
      onPointerdown: r[1] || (r[1] = (l) => {
        const u = l.target;
        u.setPointerCapture(l.pointerId), l.preventDefault(), unref(s).thumbElements.value.includes(u) ? u.focus() : n("slideStart", l);
      }),
      onPointermove: r[2] || (r[2] = (l) => {
        l.target.hasPointerCapture(l.pointerId) && n("slideMove", l);
      }),
      onPointerup: r[3] || (r[3] = (l) => {
        const u = l.target;
        u.hasPointerCapture(l.pointerId) && (u.releasePointerCapture(l.pointerId), n("slideEnd", l));
      })
    }), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var hi = defineComponent({
  __name: "SliderHorizontal",
  props: {
    dir: {},
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(o, { emit: t }) {
    const e = o, n = t, { max: s, min: i, dir: r, inverted: l } = toRefs(e), { primitiveElement: u, currentElement: d } = V(), c = ref(), p = computed(() => (r == null ? void 0 : r.value) === "ltr" && !l.value || (r == null ? void 0 : r.value) !== "ltr" && l.value);
    function f(m) {
      const C = c.value || d.value.getBoundingClientRect(), _ = [0, C.width], $ = p.value ? [i.value, s.value] : [s.value, i.value], E = _o(_, $);
      return c.value = C, E(m - C.left);
    }
    return Rn({
      startEdge: p.value ? "left" : "right",
      endEdge: p.value ? "right" : "left",
      direction: p.value ? 1 : -1,
      size: "width"
    }), (m, C) => (openBlock(), createBlock(Fn, {
      ref_key: "primitiveElement",
      ref: u,
      dir: unref(r),
      "data-orientation": "horizontal",
      style: normalizeStyle({
        "--radix-slider-thumb-transform": "translateX(-50%)"
      }),
      onSlideStart: C[0] || (C[0] = (_) => {
        const $ = f(_.clientX);
        n("slideStart", $);
      }),
      onSlideMove: C[1] || (C[1] = (_) => {
        const $ = f(_.clientX);
        n("slideMove", $);
      }),
      onSlideEnd: C[2] || (C[2] = () => {
        c.value = void 0, n("slideEnd");
      }),
      onStepKeyDown: C[3] || (C[3] = (_) => {
        const $ = p.value ? "from-left" : "from-right", E = unref(Mn)[$].includes(_.key);
        n("stepKeyDown", _, E ? -1 : 1);
      }),
      onEndKeyDown: C[4] || (C[4] = (_) => n("endKeyDown", _)),
      onHomeKeyDown: C[5] || (C[5] = (_) => n("homeKeyDown", _))
    }, {
      default: withCtx(() => [
        renderSlot(m.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir", "style"]));
  }
});
var yi = defineComponent({
  __name: "SliderVertical",
  props: {
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(o, { emit: t }) {
    const e = o, n = t, { max: s, min: i, inverted: r } = toRefs(e), { primitiveElement: l, currentElement: u } = V(), d = ref(), c = computed(() => !r.value);
    function p(f) {
      const m = d.value || u.value.getBoundingClientRect(), C = [0, m.height], _ = c.value ? [s.value, i.value] : [i.value, s.value], $ = _o(C, _);
      return d.value = m, $(f - m.top);
    }
    return Rn({
      startEdge: c.value ? "bottom" : "top",
      endEdge: c.value ? "top" : "bottom",
      size: "height",
      direction: c.value ? 1 : -1
    }), (f, m) => (openBlock(), createBlock(Fn, {
      ref_key: "primitiveElement",
      ref: l,
      "data-orientation": "vertical",
      style: normalizeStyle({
        "--radix-slider-thumb-transform": "translateY(50%)"
      }),
      onSlideStart: m[0] || (m[0] = (C) => {
        const _ = p(C.clientY);
        n("slideStart", _);
      }),
      onSlideMove: m[1] || (m[1] = (C) => {
        const _ = p(C.clientY);
        n("slideMove", _);
      }),
      onSlideEnd: m[2] || (m[2] = () => {
        d.value = void 0, n("slideEnd");
      }),
      onStepKeyDown: m[3] || (m[3] = (C) => {
        const _ = c.value ? "from-bottom" : "from-top", $ = unref(Mn)[_].includes(C.key);
        n("stepKeyDown", C, $ ? -1 : 1);
      }),
      onEndKeyDown: m[4] || (m[4] = (C) => n("endKeyDown", C)),
      onHomeKeyDown: m[5] || (m[5] = (C) => n("homeKeyDown", C))
    }, {
      default: withCtx(() => [
        renderSlot(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
});
var gi = ["value", "name", "disabled"];
var [Dt, bi] = H("SliderRoot");
var ru = defineComponent({
  inheritAttrs: false,
  __name: "SliderRoot",
  props: {
    name: {},
    defaultValue: { default: () => [0] },
    modelValue: {},
    disabled: { type: Boolean, default: false },
    orientation: { default: "horizontal" },
    dir: {},
    inverted: { type: Boolean, default: false },
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    minStepsBetweenThumbs: { default: 0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(o, { emit: t }) {
    const e = o, n = t, { min: s, max: i, step: r, minStepsBetweenThumbs: l, orientation: u, disabled: d, dir: c } = toRefs(e), p = pe(c), { createCollection: f } = ne("sliderThumb"), { primitiveElement: m, currentElement: C } = V();
    f(C);
    const _ = ze(C), $ = X(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), E = ref(0), w = ref($.value);
    function P(F) {
      const N = di($.value, F);
      A(F, N);
    }
    function B(F) {
      A(F, E.value);
    }
    function I() {
      const F = w.value[E.value];
      $.value[E.value] !== F && n("valueCommit", $.value);
    }
    function A(F, N, { commit: S } = { commit: false }) {
      var ee;
      const K = vi(r.value), z = mi(Math.round((F - s.value) / r.value) * r.value + s.value, K), k = On(z, [s.value, i.value]), j = li($.value, k, N);
      if (fi(j, l.value * r.value)) {
        E.value = j.indexOf(k);
        const ie = String(j) !== String($.value);
        ie && S && n("valueCommit", j), ie && ((ee = W.value[E.value]) == null || ee.focus(), $.value = j);
      }
    }
    const W = ref([]);
    return bi({
      modelValue: $,
      valueIndexToChangeRef: E,
      thumbElements: W,
      orientation: u,
      min: s,
      max: i,
      disabled: d
    }), (F, N) => (openBlock(), createElementBlock(Fragment, null, [
      (openBlock(), createBlock(resolveDynamicComponent(unref(u) === "horizontal" ? hi : yi), mergeProps(F.$attrs, {
        ref_key: "primitiveElement",
        ref: m,
        "as-child": F.asChild,
        as: F.as,
        min: unref(s),
        max: unref(i),
        dir: unref(p),
        inverted: F.inverted,
        "aria-disabled": unref(d),
        "data-disabled": unref(d),
        onPointerdown: N[0] || (N[0] = () => {
          unref(d) || (w.value = unref($));
        }),
        onSlideStart: N[1] || (N[1] = (S) => !unref(d) && P(S)),
        onSlideMove: N[2] || (N[2] = (S) => !unref(d) && B(S)),
        onSlideEnd: N[3] || (N[3] = (S) => !unref(d) && I),
        onHomeKeyDown: N[4] || (N[4] = (S) => !unref(d) && A(unref(s), 0, { commit: true })),
        onEndKeyDown: N[5] || (N[5] = (S) => !unref(d) && A(unref(i), unref($).length - 1, { commit: true })),
        onStepKeyDown: N[6] || (N[6] = (S, K) => {
          if (!unref(d)) {
            const j = unref(An).includes(S.key) || S.shiftKey && unref(In).includes(S.key) ? 10 : 1, ee = E.value, ie = unref($)[ee], Ht = unref(r) * j * K;
            A(ie + Ht, ee, { commit: true });
          }
        })
      }), {
        default: withCtx(() => [
          renderSlot(F.$slots, "default", { modelValue: unref($) })
        ]),
        _: 3
      }, 16, ["as-child", "as", "min", "max", "dir", "inverted", "aria-disabled", "data-disabled"])),
      unref(_) ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref($), (S, K) => (openBlock(), createElementBlock("input", {
        key: K,
        value: S,
        type: "number",
        style: { display: "none" },
        name: F.name ? F.name + (unref($).length > 1 ? "[]" : "") : void 0,
        disabled: unref(d)
      }, null, 8, gi))), 128)) : createCommentVNode("", true)
    ], 64));
  }
});
var Ci = defineComponent({
  inheritAttrs: false,
  __name: "SliderThumbImpl",
  props: {
    index: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o, { expose: t }) {
    const e = o, n = Dt(), s = kn(), { primitiveElement: i, currentElement: r } = V(), l = computed(() => {
      var C, _;
      return (_ = (C = n.modelValue) == null ? void 0 : C.value) == null ? void 0 : _[e.index];
    }), u = computed(() => l.value === void 0 ? 0 : Dn(l.value, n.min.value ?? 0, n.max.value ?? 100)), d = computed(() => {
      var C, _;
      return ui(e.index, ((_ = (C = n.modelValue) == null ? void 0 : C.value) == null ? void 0 : _.length) ?? 0);
    }), c = yn(r), p = computed(() => c[s.size].value), f = computed(() => p.value ? ci(p.value, u.value, s.direction) : 0), m = Pt();
    return onMounted(() => {
      n.thumbElements.value.push(r.value);
    }), onUnmounted(() => {
      const C = n.thumbElements.value.findIndex((_) => _ === r.value) ?? -1;
      n.thumbElements.value.splice(C, 1);
    }), t({
      $el: r
    }), (C, _) => (openBlock(), createBlock(unref(D), mergeProps(C.$attrs, {
      ref_key: "primitiveElement",
      ref: i,
      role: "slider",
      "data-radix-vue-collection-item": "",
      tabindex: unref(n).disabled.value ? void 0 : 0,
      "aria-label": C.$attrs["aria-label"] || d.value,
      "data-disabled": unref(n).disabled.value,
      "data-orientation": unref(n).orientation.value,
      "aria-valuenow": l.value,
      "aria-valuemin": unref(n).min.value,
      "aria-valuemax": unref(n).max.value,
      "aria-orientation": unref(n).orientation.value,
      "as-child": C.asChild,
      as: C.as,
      style: {
        transform: "var(--radix-slider-thumb-transform)",
        position: "absolute",
        [unref(s).startEdge]: `calc(${u.value}% + ${f.value}px)`,
        /**
         * There will be no value on initial render while we work out the index so we hide thumbs
         * without a value, otherwise SSR will render them in the wrong position before they
         * snap into the correct position during hydration which would be visually jarring for
         * slower connections.
         */
        display: !unref(m) && l.value === void 0 ? "none" : void 0
      },
      onFocus: _[0] || (_[0] = () => {
        unref(n).valueIndexToChangeRef.value = C.index;
      })
    }), {
      default: withCtx(() => [
        renderSlot(C.$slots, "default")
      ]),
      _: 3
    }, 16, ["tabindex", "aria-label", "data-disabled", "data-orientation", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "as-child", "as", "style"]));
  }
});
var lu = defineComponent({
  __name: "SliderThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { injectCollection: e } = ne("sliderThumb"), n = e(), { primitiveElement: s, currentElement: i } = V(), r = computed(() => i.value ? n.value.findIndex((l) => l === i.value) : -1);
    return (l, u) => (openBlock(), createBlock(Ci, mergeProps({
      ref_key: "primitiveElement",
      ref: s
    }, t, { index: r.value }), {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["index"]));
  }
});
var uu = defineComponent({
  __name: "SliderTrack",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = Dt();
    return (n, s) => (openBlock(), createBlock(unref(D), {
      "as-child": t.asChild,
      as: n.as,
      "data-disabled": unref(e).disabled.value,
      "data-orientation": unref(e).orientation.value
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "data-disabled", "data-orientation"]));
  }
});
var du = defineComponent({
  __name: "SliderRange",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = Dt(), e = kn(), n = computed(() => {
      var r, l;
      return (l = (r = t.modelValue) == null ? void 0 : r.value) == null ? void 0 : l.map(
        (u) => Dn(u, t.min.value, t.max.value)
      );
    }), s = computed(() => t.modelValue.value.length > 1 ? Math.min(...n.value) : 0), i = computed(() => 100 - Math.max(...n.value));
    return (r, l) => (openBlock(), createBlock(unref(D), {
      "data-disabled": unref(t).disabled.value,
      "data-orientation": unref(t).orientation.value,
      "as-child": r.asChild,
      as: r.as,
      style: normalizeStyle({
        [unref(e).startEdge]: `${s.value}%`,
        [unref(e).endEdge]: `${i.value}%`
      })
    }, {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-disabled", "data-orientation", "as-child", "as", "style"]));
  }
});
var [_i, wi] = H("RadioGroupRoot");
var cu = defineComponent({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean, default: false },
    name: {},
    required: { type: Boolean, default: false },
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: true },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "modelValue", t, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), { disabled: i, loop: r, orientation: l, name: u, required: d, dir: c } = toRefs(e), p = pe(c);
    return wi({
      modelValue: s,
      changeModelValue: (f) => {
        s.value = f;
      },
      disabled: i,
      loop: r,
      orientation: l,
      name: u == null ? void 0 : u.value,
      required: d
    }), (f, m) => (openBlock(), createBlock(unref(qe), {
      "as-child": "",
      orientation: unref(l),
      dir: unref(p),
      loop: unref(r)
    }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          role: "radiogroup",
          "data-disabled": unref(i) ? "" : void 0,
          "as-child": f.asChild,
          as: f.as,
          required: unref(d),
          "aria-orientation": unref(l),
          "aria-required": unref(d),
          dir: unref(p),
          name: unref(u)
        }, {
          default: withCtx(() => [
            renderSlot(f.$slots, "default")
          ]),
          _: 3
        }, 8, ["data-disabled", "as-child", "as", "required", "aria-orientation", "aria-required", "dir", "name"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
});
var Ei = ["value", "checked", "name", "disabled", "required"];
var xi = defineComponent({
  __name: "Radio",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: false },
    required: { type: Boolean },
    checked: { type: Boolean, default: void 0 },
    name: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  emits: ["update:checked"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "checked", t, {
      passive: e.checked === void 0
    }), { value: i } = toRefs(e), { primitiveElement: r, currentElement: l } = V(), u = ze(l), d = computed(() => {
      var p;
      return e.id && l.value ? ((p = document.querySelector(`[for="${e.id}"]`)) == null ? void 0 : p.innerText) ?? e.value : void 0;
    });
    function c(p) {
      s.value = true, u.value && p.stopPropagation();
    }
    return (p, f) => (openBlock(), createBlock(unref(D), mergeProps(p.$attrs, {
      id: p.id,
      ref_key: "primitiveElement",
      ref: r,
      role: "radio",
      type: p.as === "button" ? "button" : void 0,
      as: p.as,
      "aria-checked": unref(s),
      "aria-label": d.value,
      "as-child": p.asChild,
      disabled: p.disabled ? true : void 0,
      "data-state": unref(s) ? "checked" : "unchecked",
      "data-disabled": p.disabled ? "" : void 0,
      value: unref(i),
      required: p.required,
      name: p.name,
      onClick: withModifiers(c, ["stop"])
    }), {
      default: withCtx(() => [
        renderSlot(p.$slots, "default"),
        unref(u) ? (openBlock(), createElementBlock("input", {
          key: 0,
          type: "radio",
          tabindex: "-1",
          "aria-hidden": "",
          value: unref(i),
          checked: !!unref(s),
          name: p.name,
          disabled: p.disabled,
          required: p.required,
          style: normalizeStyle({
            transform: "translateX(-100%)",
            position: "absolute",
            pointerEvents: "none",
            opacity: 0,
            margin: 0
          })
        }, null, 12, Ei)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["id", "type", "as", "aria-checked", "aria-label", "as-child", "disabled", "data-state", "data-disabled", "value", "required", "name", "onClick"]));
  }
});
var [$i, Pi] = H("RadioGroupItem");
var pu = defineComponent({
  inheritAttrs: false,
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: false },
    required: { type: Boolean },
    name: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = V(), s = _i(), i = computed(() => s.disabled.value || t.disabled), r = computed(() => s.required.value || t.required), l = computed(() => {
      var p;
      return ((p = s.modelValue) == null ? void 0 : p.value) === t.value;
    });
    Pi({ disabled: i, checked: l });
    const u = ref(false), d = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
    et("keydown", (p) => {
      d.includes(p.key) && (u.value = true);
    }), et("keyup", () => {
      u.value = false;
    });
    function c() {
      setTimeout(() => {
        var p;
        u.value && ((p = n.value) == null || p.click());
      }, 0);
    }
    return (p, f) => (openBlock(), createBlock(unref(Ye), {
      checked: l.value,
      disabled: i.value,
      "as-child": "",
      focusable: !i.value,
      active: l.value
    }, {
      default: withCtx(() => [
        createVNode(xi, mergeProps({
          ref_key: "primitiveElement",
          ref: e
        }, { ...p.$attrs, ...t }, {
          checked: l.value,
          required: r.value,
          "onUpdate:checked": f[0] || (f[0] = (m) => unref(s).changeModelValue(p.value)),
          onKeydown: f[1] || (f[1] = withKeys(withModifiers(() => {
          }, ["prevent"]), ["enter"])),
          onFocus: c
        }), {
          default: withCtx(() => [
            renderSlot(p.$slots, "default")
          ]),
          _: 3
        }, 16, ["checked", "required"])
      ]),
      _: 3
    }, 8, ["checked", "disabled", "focusable", "active"]));
  }
});
var fu = defineComponent({
  __name: "RadioGroupIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = $i();
    return (e, n) => unref(t).checked.value ? (openBlock(), createBlock(unref(D), {
      key: 0,
      "data-state": unref(t).checked.value ? "checked" : "unchecked",
      "data-disabled": unref(t).disabled.value ? "" : void 0,
      "as-child": e.asChild,
      as: e.as
    }, {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-state", "data-disabled", "as-child", "as"])) : createCommentVNode("", true);
  }
});
var [Xe, Bi] = H("PaginationRoot");
var vu = defineComponent({
  __name: "PaginationRoot",
  props: {
    page: {},
    defaultPage: { default: 1 },
    itemsPerPage: { default: 10 },
    total: { default: 0 },
    siblingCount: { default: 2 },
    disabled: { type: Boolean },
    showEdges: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:page"],
  setup(o, { emit: t }) {
    const e = o, n = t, { siblingCount: s, disabled: i, showEdges: r } = toRefs(e), l = X(e, "page", n, {
      defaultValue: e.defaultPage,
      passive: e.page === void 0
    }), u = computed(() => Math.ceil(e.total / e.itemsPerPage));
    return Bi({
      page: l,
      onPageChange(d) {
        l.value = d;
      },
      pageCount: u,
      siblingCount: s,
      disabled: i,
      showEdges: r
    }), (d, c) => (openBlock(), createBlock(unref(D), {
      as: d.as,
      "as-child": d.asChild
    }, {
      default: withCtx(() => [
        renderSlot(d.$slots, "default", { page: unref(l) })
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
var mu = defineComponent({
  __name: "PaginationEllipsis",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(D), mergeProps({ "data-type": "ellipsis" }, t), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default", {}, () => [
          createTextVNode("…")
        ])
      ]),
      _: 3
    }, 16));
  }
});
var hu = defineComponent({
  __name: "PaginationFirst",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Xe();
    return (n, s) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      "aria-label": "First Page",
      type: n.as === "button" ? "button" : void 0,
      disabled: unref(e).page.value === 1 || unref(e).disabled.value,
      onClick: s[0] || (s[0] = (i) => unref(e).onPageChange(1))
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default", {}, () => [
          createTextVNode("First page")
        ])
      ]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
});
var yu = defineComponent({
  __name: "PaginationLast",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Xe();
    return (n, s) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      "aria-label": "Last Page",
      type: n.as === "button" ? "button" : void 0,
      disabled: unref(e).page.value === unref(e).pageCount.value || unref(e).disabled.value,
      onClick: s[0] || (s[0] = (i) => unref(e).onPageChange(unref(e).pageCount.value))
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default", {}, () => [
          createTextVNode("Last page")
        ])
      ]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
});
function ke(o, t) {
  const e = t - o + 1;
  return Array.from({ length: e }, (n, s) => s + o);
}
function Si(o) {
  return o.map((t) => typeof t == "number" ? { type: "page", value: t } : { type: "ellipsis" });
}
var mt = "ellipsis";
function Ti(o, t, e, n) {
  const i = t, r = Math.max(o - e, 1), l = Math.min(o + e, i), u = r > 1 + 1, d = l < i - 1;
  if (n) {
    const p = Math.min(2 * e + 5, t) - 2;
    if (!u && d)
      return [...ke(1, p), mt, i];
    if (u && !d) {
      const m = ke(i - p + 1, i);
      return [1, mt, ...m];
    }
    if (u && d) {
      const m = ke(r, l);
      return [1, mt, ...m, mt, i];
    }
    return ke(1, i);
  } else {
    const c = e * 2 + 1;
    return o <= e + 1 ? ke(1, c) : t - o <= e ? ke(t - c + 1, i) : ke(r, l);
  }
}
var gu = defineComponent({
  __name: "PaginationList",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Xe(), n = computed(() => Si(
      Ti(
        e.page.value,
        e.pageCount.value,
        e.siblingCount.value,
        e.showEdges.value
      )
    ));
    return (s, i) => (openBlock(), createBlock(unref(D), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default", { items: n.value })
      ]),
      _: 3
    }, 16));
  }
});
var bu = defineComponent({
  __name: "PaginationListItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Xe(), n = computed(() => e.page.value === t.value);
    return (s, i) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      "data-type": "page",
      "aria-label": `Page ${s.value}`,
      "aria-current": n.value ? "page" : void 0,
      "data-selected": n.value ? "true" : void 0,
      disabled: unref(e).disabled.value,
      type: s.as === "button" ? "button" : void 0,
      onClick: i[0] || (i[0] = (r) => unref(e).onPageChange(s.value))
    }), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(s.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-label", "aria-current", "data-selected", "disabled", "type"]));
  }
});
var Cu = defineComponent({
  __name: "PaginationNext",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Xe();
    return (n, s) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      "aria-label": "Next Page",
      type: n.as === "button" ? "button" : void 0,
      disabled: unref(e).page.value === unref(e).pageCount.value || unref(e).disabled.value,
      onClick: s[0] || (s[0] = (i) => unref(e).onPageChange(unref(e).page.value + 1))
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default", {}, () => [
          createTextVNode("Next page")
        ])
      ]),
      _: 3
    }, 16, ["type", "disabled"]));
  }
});
var _u = defineComponent({
  __name: "PaginationPrev",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Xe();
    return (n, s) => {
      var i;
      return openBlock(), createBlock(unref(D), mergeProps(t, {
        "aria-label": "Previous Page",
        type: n.as === "button" ? "button" : void 0,
        disabled: unref(e).page.value === 1 || ((i = unref(e).disabled) == null ? void 0 : i.value),
        onClick: s[0] || (s[0] = (r) => unref(e).onPageChange(unref(e).page.value - 1))
      }), {
        default: withCtx(() => [
          renderSlot(n.$slots, "default", {}, () => [
            createTextVNode("Prev page")
          ])
        ]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});
var tt = 100;
var [Oi, Di] = H("ProgressRoot");
var wo = (o) => typeof o == "number";
function Ai(o, t) {
  return o === null || wo(o) && !Number.isNaN(o) && o <= t && o >= 0 ? o : (console.error(`Invalid prop \`value\` of value \`${o}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${tt} if no \`max\` prop is set)
  - \`null\` if the progress is indeterminate.

Defaulting to \`null\`.`), null);
}
function Ii(o) {
  return wo(o) && !Number.isNaN(o) && o > 0 ? o : (console.error(
    `Invalid prop \`max\` of value \`${o}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${tt}\`.`
  ), tt);
}
var wu = defineComponent({
  __name: "ProgressRoot",
  props: {
    modelValue: {},
    max: { default: tt },
    getValueLabel: { type: Function, default: (o, t) => `${Math.round(o / t * tt)}%` },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue", "update:max"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = X(e, "modelValue", n, {
      passive: e.modelValue === void 0
    }), i = X(e, "max", n, {
      passive: e.max === void 0
    });
    watch(
      () => s.value,
      async (l) => {
        const u = Ai(l, e.max);
        u !== l && (await nextTick(), s.value = u);
      },
      { immediate: true }
    ), watch(
      () => e.max,
      (l) => {
        const u = Ii(e.max);
        u !== l && (i.value = u);
      },
      { immediate: true }
    );
    const r = computed(() => s.value ? s.value === i.value ? "complete" : "loading" : "indeterminate");
    return Di({
      modelValue: s,
      max: i,
      progressState: r
    }), (l, u) => (openBlock(), createBlock(unref(D), {
      "as-child": e.asChild,
      as: l.as,
      "aria-valuemax": unref(i),
      "aria-valuemin": 0,
      "aria-valuenow": wo(unref(s)) ? unref(s) : void 0,
      "aria-valuetext": l.getValueLabel(unref(s), unref(i)),
      "aria-label": l.getValueLabel(unref(s), unref(i)),
      role: "progressbar",
      "data-state": r.value,
      "data-value": unref(s) ?? void 0,
      "data-max": unref(i)
    }, {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-label", "data-state", "data-value", "data-max"]));
  }
});
var Eu = defineComponent({
  __name: "ProgressIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Oi();
    return (n, s) => {
      var i;
      return openBlock(), createBlock(unref(D), mergeProps(t, {
        "data-state": unref(e).progressState.value,
        "data-value": ((i = unref(e).modelValue) == null ? void 0 : i.value) ?? void 0,
        "data-max": unref(e).max.value
      }), {
        default: withCtx(() => [
          renderSlot(n.$slots, "default")
        ]),
        _: 3
      }, 16, ["data-state", "data-value", "data-max"]);
    };
  }
});
var [ye, Mi] = H("DialogRoot");
var ki = defineComponent({
  __name: "DialogRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: false },
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), i = ref(), r = ref(), { modal: l } = toRefs(e);
    return Mi({
      open: s,
      modal: l,
      openModal: () => {
        s.value = true;
      },
      onOpenChange: (u) => {
        s.value = u;
      },
      onOpenToggle: () => {
        s.value = !s.value;
      },
      contentId: te(),
      titleId: te(),
      descriptionId: te(),
      triggerElement: i,
      contentElement: r
    }), (u, d) => renderSlot(u.$slots, "default");
  }
});
var Ri = defineComponent({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = ye(), { primitiveElement: n, currentElement: s } = V();
    return onMounted(() => {
      e.triggerElement = s;
    }), (i, r) => (openBlock(), createBlock(unref(D), mergeProps({
      ref_key: "primitiveElement",
      ref: n
    }, t, {
      type: i.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": unref(e).open.value || false,
      "aria-controls": unref(e).contentId,
      "data-state": unref(e).open.value ? "open" : "closed",
      onClick: unref(e).onOpenToggle
    }), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "onClick"]));
  }
});
var xu = defineComponent({
  __name: "DialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Se), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Xt = "focusScope.autoFocusOnMount";
var Jt = "focusScope.autoFocusOnUnmount";
var Jo = { bubbles: false, cancelable: true };
function gt(o, { select: t = false } = {}) {
  const e = document.activeElement;
  for (const n of o)
    if (xe(n, { select: t }), document.activeElement !== e)
      return true;
}
function Fi(o) {
  const t = Eo(o), e = Zo(t, o), n = Zo(t.reverse(), o);
  return [e, n];
}
function Eo(o) {
  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const s = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
function Zo(o, t) {
  for (const e of o)
    if (!Vi(e, { upTo: t }))
      return e;
}
function Vi(o, { upTo: t }) {
  if (getComputedStyle(o).visibility === "hidden")
    return true;
  for (; o; ) {
    if (t !== void 0 && o === t)
      return false;
    if (getComputedStyle(o).display === "none")
      return true;
    o = o.parentElement;
  }
  return false;
}
function Li(o) {
  return o instanceof HTMLInputElement && "select" in o;
}
function xe(o, { select: t = false } = {}) {
  if (o && o.focus) {
    const e = document.activeElement;
    o.focus({ preventScroll: true }), o !== e && Li(o) && t && o.select();
  }
}
var Ki = xt(() => ref([]));
function Ni() {
  const o = Ki();
  return {
    add(t) {
      const e = o.value[0];
      t !== e && (e == null || e.pause()), o.value = Qo(o.value, t), o.value.unshift(t);
    },
    remove(t) {
      var e;
      o.value = Qo(o.value, t), (e = o.value[0]) == null || e.resume();
    }
  };
}
function Qo(o, t) {
  const e = [...o], n = e.indexOf(t);
  return n !== -1 && e.splice(n, 1), e;
}
function Hi(o) {
  return o.filter((t) => t.tagName !== "A");
}
var At = defineComponent({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: false },
    trapped: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, { primitiveElement: s, currentElement: i } = V(), r = ref(null), l = Ni(), u = reactive({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    });
    watchEffect((c) => {
      if (!Pe)
        return;
      const p = i.value;
      if (!e.trapped)
        return;
      function f($) {
        if (u.paused || !p)
          return;
        const E = $.target;
        p.contains(E) ? r.value = E : xe(r.value, { select: true });
      }
      function m($) {
        if (u.paused || !p)
          return;
        const E = $.relatedTarget;
        E !== null && (p.contains(E) || xe(r.value, { select: true }));
      }
      function C($) {
        if (document.activeElement === document.body)
          for (const w of $)
            w.removedNodes.length > 0 && xe(p);
      }
      document.addEventListener("focusin", f), document.addEventListener("focusout", m);
      const _ = new MutationObserver(C);
      p && _.observe(p, { childList: true, subtree: true }), c(() => {
        document.removeEventListener("focusin", f), document.removeEventListener("focusout", m), _.disconnect();
      });
    }), watchEffect(async (c) => {
      const p = i.value;
      if (await nextTick(), !p)
        return;
      l.add(u);
      const f = document.activeElement;
      if (!p.contains(f)) {
        const C = new CustomEvent(Xt, Jo);
        p.addEventListener(
          Xt,
          (_) => n("mountAutoFocus", _)
        ), p.dispatchEvent(C), C.defaultPrevented || (gt(Hi(Eo(p)), {
          select: true
        }), document.activeElement === f && xe(p));
      }
      c(() => {
        p.removeEventListener(
          Xt,
          ($) => n("mountAutoFocus", $)
        );
        const C = new CustomEvent(Jt, Jo), _ = ($) => {
          n("unmountAutoFocus", $);
        };
        p.addEventListener(Jt, _), p.dispatchEvent(C), setTimeout(() => {
          C.defaultPrevented || xe(f ?? document.body, { select: true }), p.removeEventListener(Jt, _), l.remove(u);
        }, 0);
      });
    });
    function d(c) {
      if (!e.loop && !e.trapped || u.paused)
        return;
      const p = c.key === "Tab" && !c.altKey && !c.ctrlKey && !c.metaKey, f = document.activeElement;
      if (p && f) {
        const m = c.currentTarget, [C, _] = Fi(m);
        C && _ ? !c.shiftKey && f === _ ? (c.preventDefault(), e.loop && xe(C, { select: true })) : c.shiftKey && f === C && (c.preventDefault(), e.loop && xe(_, { select: true })) : f === m && c.preventDefault();
      }
    }
    return (c, p) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: s,
      tabindex: "-1",
      "as-child": e.asChild,
      as: e.as,
      onKeydown: d
    }, {
      default: withCtx(() => [
        renderSlot(c.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
});
var Wi = "menu.itemSelect";
var eo = ["Enter", " "];
var zi = ["ArrowDown", "PageUp", "Home"];
var Vn = ["ArrowUp", "PageDown", "End"];
var ji = [...zi, ...Vn];
var Ui = {
  ltr: [...eo, "ArrowRight"],
  rtl: [...eo, "ArrowLeft"]
};
var Gi = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function xo(o) {
  return o ? "open" : "closed";
}
function _t(o) {
  return o === "indeterminate";
}
function $o(o) {
  return _t(o) ? "indeterminate" : o ? "checked" : "unchecked";
}
function to(o) {
  const t = document.activeElement;
  for (const e of o)
    if (e === t || (e.focus(), document.activeElement !== t))
      return;
}
function qi(o, t) {
  const { x: e, y: n } = o;
  let s = false;
  for (let i = 0, r = t.length - 1; i < t.length; r = i++) {
    const l = t[i].x, u = t[i].y, d = t[r].x, c = t[r].y;
    u > n != c > n && e < (d - l) * (n - u) / (c - u) + l && (s = !s);
  }
  return s;
}
function Yi(o, t) {
  if (!t)
    return false;
  const e = { x: o.clientX, y: o.clientY };
  return qi(e, t);
}
function ot(o) {
  return o.pointerType === "mouse";
}
function Xi() {
  const o = "DialogContent", t = "DialogTitle", e = ye(), n = `Warning: \`${o}\` requires a \`${t}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.radix-vue.com/components/dialog.html#title;`, s = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${o}.`;
  onMounted(() => {
    var l;
    document.getElementById(e.titleId) || console.warn(n);
    const r = (l = e.contentElement.value) == null ? void 0 : l.getAttribute("aria-describedby");
    e.descriptionId && r && (document.getElementById(e.descriptionId) || console.warn(s));
  });
}
var Ln = defineComponent({
  __name: "DialogContentImpl",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ye(), { primitiveElement: i, currentElement: r } = V();
    return onMounted(() => {
      s.contentElement = r;
    }), Xi(), (l, u) => (openBlock(), createBlock(unref(At), {
      "as-child": "",
      loop: "",
      trapped: e.trapFocus,
      onMountAutoFocus: u[5] || (u[5] = (d) => n("openAutoFocus", d)),
      onUnmountAutoFocus: u[6] || (u[6] = (d) => n("closeAutoFocus", d))
    }, {
      default: withCtx(() => [
        createVNode(unref(Be), mergeProps({
          id: unref(s).contentId,
          ref_key: "primitiveElement",
          ref: i,
          as: l.as,
          "as-child": l.asChild,
          "disable-outside-pointer-events": l.disableOutsidePointerEvents,
          role: "dialog",
          "aria-describedby": unref(s).descriptionId,
          "aria-labelledby": unref(s).titleId,
          "data-state": unref(xo)(unref(s).open.value)
        }, l.$attrs, {
          onDismiss: u[0] || (u[0] = (d) => unref(s).onOpenChange(false)),
          onEscapeKeyDown: u[1] || (u[1] = (d) => n("escapeKeyDown", d)),
          onFocusOutside: u[2] || (u[2] = (d) => n("focusOutside", d)),
          onInteractOutside: u[3] || (u[3] = (d) => n("interactOutside", d)),
          onPointerDownOutside: u[4] || (u[4] = (d) => n("pointerDownOutside", d))
        }), {
          default: withCtx(() => [
            renderSlot(l.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
});
var Ji = defineComponent({
  __name: "DialogContentModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ye(), i = le(n), { primitiveElement: r, currentElement: l } = V();
    return rt(l), (u, d) => (openBlock(), createBlock(Ln, mergeProps({
      ref_key: "primitiveElement",
      ref: r
    }, { ...e, ...unref(i) }, {
      "trap-focus": unref(s).open.value,
      "disable-outside-pointer-events": true,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        var p;
        n("closeAutoFocus", c), c.defaultPrevented || (c.preventDefault(), (p = unref(s).triggerElement.value) == null || p.focus());
      }),
      onPointerDownOutside: d[1] || (d[1] = (c) => {
        const p = c.detail.originalEvent, f = p.button === 0 && p.ctrlKey === true;
        (p.button === 2 || f) && c.preventDefault();
      }),
      onFocusOutside: d[2] || (d[2] = (c) => {
        c.preventDefault();
      }),
      onOpenAutoFocus: d[3] || (d[3] = (c) => n("openAutoFocus", c))
    }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
});
var Zi = defineComponent({
  __name: "DialogContentNonModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = le(n), i = ye(), r = ref(false), l = ref(false);
    return (u, d) => (openBlock(), createBlock(Ln, mergeProps({ ...e, ...unref(s) }, {
      "trap-focus": false,
      "disable-outside-pointer-events": false,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        var p;
        n("closeAutoFocus", c), c.defaultPrevented || (r.value || (p = unref(i).triggerElement.value) == null || p.focus(), c.preventDefault()), r.value = false, l.value = false;
      }),
      onInteractOutside: d[1] || (d[1] = (c) => {
        var m;
        c.defaultPrevented || (r.value = true, c.detail.originalEvent.type === "pointerdown" && (l.value = true));
        const p = c.target;
        ((m = unref(i).triggerElement.value) == null ? void 0 : m.contains(p)) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && l.value && c.preventDefault();
      })
    }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Qi = defineComponent({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ye(), i = le(n);
    return (r, l) => (openBlock(), createBlock(unref(ae), {
      present: r.forceMount || unref(s).open.value
    }, {
      default: withCtx(() => [
        unref(s).modal.value ? (openBlock(), createBlock(Ji, mergeProps({ key: 0 }, { ...e, ...unref(i), ...r.$attrs }, {
          onOpenAutoFocus: l[0] || (l[0] = (u) => n("openAutoFocus", u))
        }), {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 16)) : (openBlock(), createBlock(Zi, normalizeProps(mergeProps({ key: 1 }, { ...e, ...unref(i), ...r.$attrs })), {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var er = defineComponent({
  __name: "DialogOverlayImpl",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = ye();
    return it(true), (e, n) => (openBlock(), createBlock(unref(D), {
      as: e.as,
      "as-child": e.asChild,
      "data-state": unref(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" },
      "data-aria-hidden": "true",
      "aria-hidden": "true"
    }, {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state"]));
  }
});
var tr = defineComponent({
  __name: "DialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = ye();
    return (e, n) => {
      var s;
      return (s = unref(t)) != null && s.modal.value ? (openBlock(), createBlock(unref(ae), {
        key: 0,
        present: e.forceMount || unref(t).open.value
      }, {
        default: withCtx(() => [
          createVNode(er, mergeProps({
            as: e.as,
            "as-child": e.asChild
          }, e.$attrs), {
            default: withCtx(() => [
              renderSlot(e.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child"])
        ]),
        _: 3
      }, 8, ["present"])) : createCommentVNode("", true);
    };
  }
});
var Kn = defineComponent({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = ye();
    return (n, s) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      type: n.as === "button" ? "button" : void 0,
      "aria-label": "Close",
      onClick: s[0] || (s[0] = (i) => unref(e).onOpenChange(false))
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
});
var or = defineComponent({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(o) {
    const t = o, e = ye();
    return (n, s) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      id: unref(e).titleId
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
});
var nr = defineComponent({
  __name: "DialogDescription",
  props: {
    asChild: { type: Boolean },
    as: { default: "p" }
  },
  setup(o) {
    const t = o, e = ye();
    return (n, s) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      id: unref(e).descriptionId
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
});
var $u = defineComponent({
  __name: "AlertDialogRoot",
  props: {
    open: { type: Boolean },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const s = ue(o, t);
    return (i, r) => (openBlock(), createBlock(unref(ki), mergeProps(unref(s), { modal: true }), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Pu = defineComponent({
  __name: "AlertDialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ri), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Bu = defineComponent({
  __name: "AlertDialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Se), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [ar, sr] = H("AlertDialogContent");
var Su = defineComponent({
  __name: "AlertDialogContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, s = le(t), i = ref();
    return sr({
      onCancelElementChange: (r) => {
        i.value = r;
      }
    }), (r, l) => (openBlock(), createBlock(unref(Qi), mergeProps({ ...e, ...unref(s) }, {
      role: "alertdialog",
      onPointerDownOutside: l[0] || (l[0] = withModifiers(() => {
      }, ["prevent"])),
      onInteractOutside: l[1] || (l[1] = withModifiers(() => {
      }, ["prevent"])),
      onOpenAutoFocus: l[2] || (l[2] = () => {
        nextTick(() => {
          var u;
          (u = i.value) == null || u.focus({
            preventScroll: true
          });
        });
      })
    }), {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Tu = defineComponent({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(tr), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Ou = defineComponent({
  __name: "AlertDialogCancel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = ar(), { primitiveElement: n, currentElement: s } = V();
    return onMounted(() => {
      e.onCancelElementChange(s.value);
    }), (i, r) => (openBlock(), createBlock(unref(Kn), mergeProps(t, {
      ref_key: "primitiveElement",
      ref: n
    }), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Du = defineComponent({
  __name: "AlertDialogTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(or), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Au = defineComponent({
  __name: "AlertDialogDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(nr), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Iu = defineComponent({
  __name: "AlertDialogAction",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Kn), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [It, ir] = H("ToastProvider");
var Mu = defineComponent({
  __name: "ToastProvider",
  props: {
    label: { default: "Notification" },
    duration: { default: 5e3 },
    swipeDirection: { default: "right" },
    swipeThreshold: { default: 50 }
  },
  setup(o) {
    const t = o, { label: e, duration: n, swipeDirection: s, swipeThreshold: i } = toRefs(t), r = ref(), l = ref(0), u = ref(false), d = ref(false);
    if (t.label && typeof t.label == "string" && !t.label.trim()) {
      const c = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(c);
    }
    return ir({
      label: e,
      duration: n,
      swipeDirection: s,
      swipeThreshold: i,
      toastCount: l,
      viewport: r,
      onViewportChange(c) {
        r.value = c;
      },
      onToastAdd() {
        l.value++;
      },
      onToastRemove() {
        l.value--;
      },
      isFocusedToastEscapeKeyDownRef: u,
      isClosePausedRef: d
    }), (c, p) => renderSlot(c.$slots, "default");
  }
});
var rr = "toast.swipeStart";
var lr = "toast.swipeMove";
var ur = "toast.swipeCancel";
var dr = "toast.swipeEnd";
var cr = ["F8"];
var oo = "toast.viewportPause";
var no = "toast.viewportResume";
function ht(o, t, e) {
  const n = e.originalEvent.currentTarget, s = new CustomEvent(o, {
    bubbles: false,
    cancelable: true,
    detail: e
  });
  t && n.addEventListener(o, t, { once: true }), n.dispatchEvent(s);
}
function en(o, t, e = 0) {
  const n = Math.abs(o.x), s = Math.abs(o.y), i = n > s;
  return t === "left" || t === "right" ? i && n > e : !i && s > e;
}
function pr(o) {
  return o.nodeType === o.ELEMENT_NODE;
}
function Nn(o) {
  const t = [];
  return Array.from(o.childNodes).forEach((n) => {
    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), pr(n)) {
      const s = n.ariaHidden || n.hidden || n.style.display === "none", i = n.dataset.radixToastAnnounceExclude === "";
      if (!s)
        if (i) {
          const r = n.dataset.radixToastAnnounceAlt;
          r && t.push(r);
        } else
          t.push(...Nn(n));
    }
  }), t;
}
var fr = defineComponent({
  __name: "ToastAnnounce",
  setup(o) {
    const t = It(), e = za(1e3), n = ref(false);
    return qa(() => {
      n.value = true;
    }), (s, i) => unref(e) || n.value ? (openBlock(), createBlock(unref(Ge), { key: 0 }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(unref(t).label.value) + " ", 1),
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    })) : createCommentVNode("", true);
  }
});
var [vr, mr] = H("ToastRoot");
var hr = defineComponent({
  inheritAttrs: false,
  __name: "ToastRootImpl",
  props: {
    type: {},
    open: { type: Boolean, default: false },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = _e(), { primitiveElement: i, currentElement: r } = V(), l = It(), u = ref(null), d = ref(null), c = computed(() => e.duration || l.duration.value), p = ref(0), f = ref(c.value), m = ref(0);
    function C(E) {
      !E || E === Number.POSITIVE_INFINITY || (window.clearTimeout(m.value), p.value = (/* @__PURE__ */ new Date()).getTime(), m.value = window.setTimeout(_, E));
    }
    function _() {
      var w, P;
      ((w = r.value) == null ? void 0 : w.contains(document.activeElement)) && ((P = l.viewport.value) == null || P.focus()), n("close");
    }
    const $ = computed(() => r.value ? Nn(r.value) : null);
    if (e.type && !["foreground", "background"].includes(e.type)) {
      const E = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(E);
    }
    return watchEffect((E) => {
      const w = l.viewport.value;
      if (w) {
        const P = () => {
          C(f.value), n("resume");
        }, B = () => {
          const I = (/* @__PURE__ */ new Date()).getTime() - p.value;
          f.value = f.value - I, window.clearTimeout(m.value), n("pause");
        };
        return w.addEventListener(oo, B), w.addEventListener(no, P), () => {
          w.removeEventListener(oo, B), w.removeEventListener(no, P);
        };
      }
    }), watchEffect(() => {
      e.open && !l.isClosePausedRef.value && C(c.value);
    }), vo("Escape", (E) => {
      n("escapeKeyDown", E), E.defaultPrevented || (l.isFocusedToastEscapeKeyDownRef.value = true, _());
    }), onMounted(() => {
      l.onToastAdd();
    }), onUnmounted(() => {
      l.onToastRemove();
    }), mr({ onClose: _ }), (E, w) => (openBlock(), createElementBlock(Fragment, null, [
      $.value ? (openBlock(), createBlock(fr, {
        key: 0,
        role: "status",
        "aria-live": E.type === "foreground" ? "assertive" : "polite",
        "aria-atomic": ""
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString($.value), 1)
        ]),
        _: 1
      }, 8, ["aria-live"])) : createCommentVNode("", true),
      (openBlock(), createBlock(Teleport, {
        to: unref(l).viewport.value
      }, [
        createVNode(unref(D), mergeProps({
          ref: (P) => {
            unref(s)(P), i.value = P;
          },
          role: "status",
          "aria-live": "off",
          "aria-atomic": "",
          tabindex: "0",
          "data-radix-vue-collection-item": ""
        }, E.$attrs, {
          as: E.as,
          "as-child": E.asChild,
          "data-state": E.open ? "open" : "closed",
          "data-swipe-direction": unref(l).swipeDirection.value,
          style: { userSelect: "none", touchAction: "none" },
          onPointerdown: w[0] || (w[0] = withModifiers((P) => {
            u.value = { x: P.clientX, y: P.clientY };
          }, ["left"])),
          onPointermove: w[1] || (w[1] = (P) => {
            if (!u.value)
              return;
            const B = P.clientX - u.value.x, I = P.clientY - u.value.y, A = !!d.value, W = ["left", "right"].includes(unref(l).swipeDirection.value), F = ["left", "up"].includes(unref(l).swipeDirection.value) ? Math.min : Math.max, N = W ? F(0, B) : 0, S = W ? 0 : F(0, I), K = P.pointerType === "touch" ? 10 : 2, z = { x: N, y: S }, k = { originalEvent: P, delta: z };
            A ? (d.value = z, unref(ht)(unref(lr), (j) => n("swipeMove", j), k)) : unref(en)(z, unref(l).swipeDirection.value, K) ? (d.value = z, unref(ht)(unref(rr), (j) => n("swipeStart", j), k), P.target.setPointerCapture(P.pointerId)) : (Math.abs(B) > K || Math.abs(I) > K) && (u.value = null);
          }),
          onPointerup: w[2] || (w[2] = (P) => {
            const B = d.value, I = P.target;
            if (I.hasPointerCapture(P.pointerId) && I.releasePointerCapture(P.pointerId), d.value = null, u.value = null, B) {
              const A = P.currentTarget, W = { originalEvent: P, delta: B };
              unref(en)(B, unref(l).swipeDirection.value, unref(l).swipeThreshold.value) ? unref(ht)(unref(dr), (F) => n("swipeEnd", F), W) : unref(ht)(unref(ur), (F) => n("swipeCancel", F), W), A == null || A.addEventListener("click", (F) => F.preventDefault(), {
                once: true
              });
            }
          })
        }), {
          default: withCtx(() => [
            renderSlot(E.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])
      ], 8, ["to"]))
    ], 64));
  }
});
var ku = defineComponent({
  __name: "ToastRoot",
  props: {
    defaultOpen: { type: Boolean, default: true },
    forceMount: { type: Boolean },
    type: { default: "foreground" },
    open: { type: Boolean, default: void 0 },
    duration: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = X(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    return (i, r) => (openBlock(), createBlock(unref(ae), {
      present: i.forceMount || unref(s)
    }, {
      default: withCtx(() => [
        createVNode(hr, mergeProps({
          open: unref(s),
          type: i.type,
          as: i.as,
          "as-child": i.asChild,
          duration: i.duration
        }, i.$attrs, {
          onClose: r[0] || (r[0] = (l) => s.value = false),
          onPause: r[1] || (r[1] = (l) => n("pause")),
          onResume: r[2] || (r[2] = (l) => n("resume")),
          onEscapeKeyDown: r[3] || (r[3] = (l) => n("escapeKeyDown", l)),
          onSwipeStart: r[4] || (r[4] = (l) => {
            n("swipeStart", l), l.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: r[5] || (r[5] = (l) => {
            const { x: u, y: d } = l.detail.delta, c = l.currentTarget;
            c.setAttribute("data-swipe", "move"), c.style.setProperty("--radix-toast-swipe-move-x", `${u}px`), c.style.setProperty("--radix-toast-swipe-move-y", `${d}px`);
          }),
          onSwipeCancel: r[6] || (r[6] = (l) => {
            const u = l.currentTarget;
            u.setAttribute("data-swipe", "cancel"), u.style.removeProperty("--radix-toast-swipe-move-x"), u.style.removeProperty("--radix-toast-swipe-move-y"), u.style.removeProperty("--radix-toast-swipe-end-x"), u.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: r[7] || (r[7] = (l) => {
            const { x: u, y: d } = l.detail.delta, c = l.currentTarget;
            c.setAttribute("data-swipe", "end"), c.style.removeProperty("--radix-toast-swipe-move-x"), c.style.removeProperty("--radix-toast-swipe-move-y"), c.style.setProperty("--radix-toast-swipe-end-x", `${u}px`), c.style.setProperty("--radix-toast-swipe-end-y", `${d}px`), s.value = false;
          })
        }), {
          default: withCtx(() => [
            renderSlot(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["open", "type", "as", "as-child", "duration"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var Hn = defineComponent({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    return (t, e) => (openBlock(), createBlock(unref(D), {
      as: t.as,
      "as-child": t.asChild,
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": t.altText || void 0
    }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-radix-toast-announce-alt"]));
  }
});
var yr = defineComponent({
  __name: "ToastClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = vr();
    return (n, s) => (openBlock(), createBlock(Hn, { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(D), mergeProps(t, {
          type: n.as === "button" ? "button" : void 0,
          onClick: s[0] || (s[0] = (i) => unref(e).onClose())
        }), {
          default: withCtx(() => [
            renderSlot(n.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }));
  }
});
var Ru = defineComponent({
  __name: "ToastAction",
  props: {
    altText: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    if (!o.altText)
      throw new Error("Missing prop `altText` expected on `ToastAction`");
    return (e, n) => e.altText ? (openBlock(), createBlock(Hn, {
      key: 0,
      "alt-text": e.altText,
      "as-child": ""
    }, {
      default: withCtx(() => [
        createVNode(yr, {
          as: e.as,
          "as-child": e.asChild
        }, {
          default: withCtx(() => [
            renderSlot(e.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child"])
      ]),
      _: 3
    }, 8, ["alt-text"])) : createCommentVNode("", true);
  }
});
var tn = defineComponent({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(o, { emit: t }) {
    const e = t, n = It();
    return (s, i) => (openBlock(), createBlock(unref(Ge), {
      "aria-hidden": "",
      tabindex: "0",
      style: { position: "'fixed'" },
      onFocus: i[0] || (i[0] = (r) => {
        var d;
        const l = r.relatedTarget;
        !((d = unref(n).viewport.value) != null && d.contains(l)) && e("focusFromOutsideViewport");
      })
    }, {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }));
  }
});
var Fu = defineComponent({
  inheritAttrs: false,
  __name: "ToastViewport",
  props: {
    hotkey: { default: () => cr },
    label: { default: "Notifications ({hotkey})" },
    asChild: { type: Boolean },
    as: { default: "ol" }
  },
  setup(o) {
    const t = o, { hotkey: e, label: n } = toRefs(t), { primitiveElement: s, currentElement: i } = V(), { createCollection: r } = ne(), l = r(i), u = It(), d = computed(() => u.toastCount.value > 0), c = ref(), p = ref();
    vo(e.value, () => {
      i.value.focus();
    }), onMounted(() => {
      u.onViewportChange(i.value);
    }), watchEffect((m) => {
      const C = i.value;
      if (d.value && C) {
        const _ = () => {
          if (!u.isClosePausedRef.value) {
            const B = new CustomEvent(oo);
            C.dispatchEvent(B), u.isClosePausedRef.value = true;
          }
        }, $ = () => {
          if (u.isClosePausedRef.value) {
            const B = new CustomEvent(no);
            C.dispatchEvent(B), u.isClosePausedRef.value = false;
          }
        }, E = (B) => {
          !C.contains(B.relatedTarget) && $();
        }, w = () => {
          C.contains(document.activeElement) || $();
        }, P = (B) => {
          var W, F, N;
          const I = B.altKey || B.ctrlKey || B.metaKey;
          if (B.key === "Tab" && !I) {
            const S = document.activeElement, K = B.shiftKey;
            if (B.target === C && K) {
              (W = c.value) == null || W.focus();
              return;
            }
            const j = f({ tabbingDirection: K ? "backwards" : "forwards" }), ee = j.findIndex((ie) => ie === S);
            gt(j.slice(ee + 1)) ? B.preventDefault() : K ? (F = c.value) == null || F.focus() : (N = p.value) == null || N.focus();
          }
        };
        C.addEventListener("focusin", _), C.addEventListener("focusout", E), C.addEventListener("pointermove", _), C.addEventListener("pointerleave", w), C.addEventListener("keydown", P), window.addEventListener("blur", _), window.addEventListener("focus", $), m(() => {
          C.removeEventListener("focusin", _), C.removeEventListener("focusout", E), C.removeEventListener("pointermove", _), C.removeEventListener("pointerleave", w), C.removeEventListener("keydown", P), window.removeEventListener("blur", _), window.removeEventListener("focus", $);
        });
      }
    });
    function f({ tabbingDirection: m }) {
      const _ = l.value.map(($) => {
        const E = [$, ...Eo($)];
        return m === "forwards" ? E : E.reverse();
      });
      return (m === "forwards" ? _.reverse() : _).flat();
    }
    return (m, C) => (openBlock(), createBlock(unref(Vs), {
      role: "region",
      "aria-label": unref(n).replace("{hotkey}", unref(e).join("+").replace(/Key/g, "").replace(/Digit/g, "")),
      tabindex: "-1",
      style: normalizeStyle({
        // incase list has size when empty (e.g. padding), we remove pointer events so
        // it doesn't prevent interactions with page elements that it overlays
        pointerEvents: d.value ? void 0 : "none"
      })
    }, {
      default: withCtx(() => [
        d.value ? (openBlock(), createBlock(tn, {
          key: 0,
          ref: (_) => {
            c.value = unref(ve)(_);
          },
          onFocusFromOutsideViewport: C[0] || (C[0] = () => {
            const _ = f({
              tabbingDirection: "forwards"
            });
            unref(gt)(_);
          })
        }, null, 512)) : createCommentVNode("", true),
        createVNode(unref(D), mergeProps({
          ref_key: "primitiveElement",
          ref: s,
          tabindex: "-1",
          as: m.as,
          "as-child": m.asChild
        }, m.$attrs), {
          default: withCtx(() => [
            renderSlot(m.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child"]),
        d.value ? (openBlock(), createBlock(tn, {
          key: 1,
          ref: (_) => {
            p.value = unref(ve)(_);
          },
          onFocusFromOutsideViewport: C[1] || (C[1] = () => {
            const _ = f({
              tabbingDirection: "backwards"
            });
            unref(gt)(_);
          })
        }, null, 512)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["aria-label", "style"]));
  }
});
var Vu = defineComponent({
  __name: "ToastTitle",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(D), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Lu = defineComponent({
  __name: "ToastDescription",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(D), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Wn, gr] = H("ToolbarRoot");
var Ku = defineComponent({
  __name: "ToolbarRoot",
  props: {
    orientation: { default: "horizontal" },
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { orientation: e, dir: n } = toRefs(t), s = pe(n);
    return gr({ orientation: e, dir: s }), (i, r) => (openBlock(), createBlock(unref(qe), {
      "as-child": "",
      orientation: unref(e),
      dir: unref(s),
      loop: i.loop
    }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          role: "toolbar",
          "aria-orientation": unref(e),
          "as-child": i.asChild,
          as: i.as
        }, {
          default: withCtx(() => [
            renderSlot(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["aria-orientation", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
});
var br = defineComponent({
  __name: "ToolbarButton",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ye), {
      "as-child": "",
      focusable: !e.disabled
    }, {
      default: withCtx(() => [
        createVNode(unref(D), mergeProps({
          type: e.as === "button" ? "button" : void 0
        }, t), {
          default: withCtx(() => [
            renderSlot(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["type"])
      ]),
      _: 3
    }, 8, ["focusable"]));
  }
});
var Nu = defineComponent({
  __name: "ToolbarLink",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ye), {
      "as-child": "",
      focusable: ""
    }, {
      default: withCtx(() => [
        createVNode(unref(D), mergeProps(t, {
          onKeydown: n[0] || (n[0] = (s) => {
            var i;
            s.key === " " && ((i = s.currentTarget) == null || i.click());
          })
        }), {
          default: withCtx(() => [
            renderSlot(e.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
});
var Hu = defineComponent({
  __name: "ToolbarToggleGroup",
  props: {
    type: {},
    defaultValue: {},
    modelValue: {},
    rovingFocus: { type: Boolean },
    disabled: { type: Boolean },
    orientation: {},
    dir: {},
    loop: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Wn(), i = le(n);
    return (r, l) => (openBlock(), createBlock(unref(si), mergeProps({ ...e, ...unref(i) }, {
      "data-orientation": unref(s).orientation.value,
      dir: unref(s).dir.value,
      "roving-focus": false
    }), {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-orientation", "dir"]));
  }
});
var Wu = defineComponent({
  __name: "ToolbarToggleItem",
  props: {
    value: {},
    defaultValue: { type: Boolean },
    pressed: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(br, { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(ii), normalizeProps(guardReactiveProps(t)), {
          default: withCtx(() => [
            renderSlot(e.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }));
  }
});
var zu = defineComponent({
  __name: "ToolbarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Wn();
    return (n, s) => (openBlock(), createBlock(Pn, {
      orientation: unref(e).orientation.value,
      "as-child": t.asChild,
      as: n.as
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["orientation", "as-child", "as"]));
  }
});
var [zn, Cr] = H("AvatarRoot");
var ju = defineComponent({
  __name: "AvatarRoot",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o;
    return Cr({
      imageLoadingStatus: ref("loading")
    }), (e, n) => (openBlock(), createBlock(unref(D), {
      as: e.as,
      "as-child": t.asChild
    }, {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
function _r(o) {
  const t = ref("idle"), e = ref(false), n = (s) => () => {
    e.value && (t.value = s);
  };
  return onMounted(() => {
    e.value = true, watch(o, (s) => {
      if (!s)
        t.value = "error";
      else {
        const i = new window.Image();
        t.value = "loading", i.onload = n("loaded"), i.onerror = n("error"), i.src = s;
      }
    }, { immediate: true });
  }), onUnmounted(() => {
    e.value = false;
  }), t;
}
var Uu = defineComponent({
  __name: "AvatarImage",
  props: {
    src: {},
    asChild: { type: Boolean },
    as: { default: "img" }
  },
  emits: ["loadingStatusChange"],
  setup(o, { emit: t }) {
    const e = o, n = t, { src: s } = toRefs(e), i = zn(), r = _r(s);
    return watch(
      r,
      (l) => {
        n("loadingStatusChange", l), l !== "idle" && (i.imageLoadingStatus.value = l);
      },
      { immediate: true }
    ), (l, u) => unref(r) === "loaded" ? (openBlock(), createBlock(unref(D), {
      key: 0,
      role: "img",
      "as-child": l.asChild,
      as: l.as,
      src: unref(s)
    }, {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "src"])) : createCommentVNode("", true);
  }
});
var Gu = defineComponent({
  __name: "AvatarFallback",
  props: {
    delayMs: { default: 0 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = zn(), n = ref(false);
    let s;
    return watch(e.imageLoadingStatus, (i) => {
      i === "loading" && (n.value = false, t.delayMs ? s = setTimeout(() => {
        n.value = true, clearTimeout(s);
      }, t.delayMs) : n.value = true);
    }, { immediate: true }), (i, r) => n.value && unref(e).imageLoadingStatus.value !== "loaded" ? (openBlock(), createBlock(unref(D), {
      key: 0,
      "as-child": t.asChild,
      as: i.as
    }, {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"])) : createCommentVNode("", true);
  }
});
var jn = "tooltip.open";
function wr(o, t) {
  const e = Math.abs(t.top - o.y), n = Math.abs(t.bottom - o.y), s = Math.abs(t.right - o.x), i = Math.abs(t.left - o.x);
  switch (Math.min(e, n, s, i)) {
    case i:
      return "left";
    case s:
      return "right";
    case e:
      return "top";
    case n:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function Er(o, t, e = 5) {
  const n = [];
  switch (t) {
    case "top":
      n.push(
        { x: o.x - e, y: o.y + e },
        { x: o.x + e, y: o.y + e }
      );
      break;
    case "bottom":
      n.push(
        { x: o.x - e, y: o.y - e },
        { x: o.x + e, y: o.y - e }
      );
      break;
    case "left":
      n.push(
        { x: o.x + e, y: o.y - e },
        { x: o.x + e, y: o.y + e }
      );
      break;
    case "right":
      n.push(
        { x: o.x - e, y: o.y - e },
        { x: o.x - e, y: o.y + e }
      );
      break;
  }
  return n;
}
function xr(o) {
  const { top: t, right: e, bottom: n, left: s } = o;
  return [
    { x: s, y: t },
    { x: e, y: t },
    { x: e, y: n },
    { x: s, y: n }
  ];
}
function $r(o, t) {
  const { x: e, y: n } = o;
  let s = false;
  for (let i = 0, r = t.length - 1; i < t.length; r = i++) {
    const l = t[i].x, u = t[i].y, d = t[r].x, c = t[r].y;
    u > n != c > n && e < (d - l) * (n - u) / (c - u) + l && (s = !s);
  }
  return s;
}
function Pr(o) {
  const t = o.slice();
  return t.sort((e, n) => e.x < n.x ? -1 : e.x > n.x ? 1 : e.y < n.y ? -1 : e.y > n.y ? 1 : 0), Br(t);
}
function Br(o) {
  if (o.length <= 1)
    return o.slice();
  const t = [];
  for (let n = 0; n < o.length; n++) {
    const s = o[n];
    for (; t.length >= 2; ) {
      const i = t[t.length - 1], r = t[t.length - 2];
      if ((i.x - r.x) * (s.y - r.y) >= (i.y - r.y) * (s.x - r.x))
        t.pop();
      else
        break;
    }
    t.push(s);
  }
  t.pop();
  const e = [];
  for (let n = o.length - 1; n >= 0; n--) {
    const s = o[n];
    for (; e.length >= 2; ) {
      const i = e[e.length - 1], r = e[e.length - 2];
      if ((i.x - r.x) * (s.y - r.y) >= (i.y - r.y) * (s.x - r.x))
        e.pop();
      else
        break;
    }
    e.push(s);
  }
  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);
}
var [Po, Sr] = H("TooltipProvider");
var qu = defineComponent({
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 700 },
    skipDelayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean, default: false },
    disableClosingTrigger: { type: Boolean }
  },
  setup(o) {
    const t = o, { delayDuration: e, skipDelayDuration: n, disableHoverableContent: s, disableClosingTrigger: i } = toRefs(t), r = ref(true), l = ref(false), { start: u, stop: d } = fo(() => {
      r.value = true;
    }, n, { immediate: false });
    return Sr({
      isOpenDelayed: r,
      delayDuration: e,
      onOpen() {
        d(), r.value = false;
      },
      onClose() {
        u();
      },
      isPointerInTransitRef: l,
      onPointerInTransitChange(c) {
        l.value = c;
      },
      disableHoverableContent: s,
      disableClosingTrigger: i
    }), (c, p) => renderSlot(c.$slots, "default");
  }
});
var [Mt, Tr] = H("TooltipRoot");
var Yu = defineComponent({
  __name: "TooltipRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    delayDuration: { default: void 0 },
    disableHoverableContent: { type: Boolean, default: void 0 },
    disableClosingTrigger: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Po(), i = computed(() => e.disableHoverableContent ?? s.disableHoverableContent.value), r = computed(() => e.disableClosingTrigger ?? s.disableClosingTrigger.value), l = computed(() => e.delayDuration ?? s.delayDuration.value), u = X(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    watch(u, (E) => {
      s.onClose && (E ? (s.onOpen(), document.dispatchEvent(new CustomEvent(jn))) : s.onClose());
    });
    const d = ref(false), c = ref(), p = computed(() => u.value ? d.value ? "delayed-open" : "instant-open" : "closed"), { start: f, stop: m } = fo(() => {
      d.value = true, u.value = true;
    }, l, { immediate: false });
    function C() {
      m(), d.value = false, u.value = true;
    }
    function _() {
      m(), u.value = false;
    }
    function $() {
      f();
    }
    return Tr({
      contentId: te(),
      open: u,
      stateAttribute: p,
      trigger: c,
      onTriggerChange(E) {
        c.value = E;
      },
      onTriggerEnter() {
        s.isOpenDelayed.value ? $() : C();
      },
      onTriggerLeave() {
        i.value ? _() : m();
      },
      onOpen: C,
      onClose: _,
      disableHoverableContent: i,
      disableClosingTrigger: r
    }), (E, w) => (openBlock(), createBlock(unref(Fe), null, {
      default: withCtx(() => [
        renderSlot(E.$slots, "default")
      ]),
      _: 3
    }));
  }
});
var Xu = defineComponent({
  __name: "TooltipTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Mt(), n = Po(), { primitiveElement: s, currentElement: i } = V(), r = ref(false), l = ref(false);
    function u() {
      r.value = false;
    }
    function d() {
      r.value = true, document.addEventListener("pointerup", u, { once: true });
    }
    return onMounted(() => {
      e.onTriggerChange(i.value);
    }), (c, p) => (openBlock(), createBlock(unref(Ve), { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          ref_key: "primitiveElement",
          ref: s,
          "aria-describedby": unref(e).open.value ? unref(e).contentId : void 0,
          "data-state": unref(e).stateAttribute.value,
          as: c.as,
          "as-child": t.asChild,
          onPointermove: p[0] || (p[0] = (f) => {
            f.pointerType !== "touch" && !l.value && !unref(n).isPointerInTransitRef.value && (unref(e).onTriggerEnter(), l.value = true);
          }),
          onPointerleave: p[1] || (p[1] = (f) => {
            unref(e).onTriggerLeave(), l.value = false;
          }),
          onPointerdown: d,
          onFocus: p[2] || (p[2] = () => {
            r.value || unref(e).onOpen();
          }),
          onBlur: p[3] || (p[3] = (f) => unref(e).onClose()),
          onClick: p[4] || (p[4] = () => {
            unref(e).disableClosingTrigger.value || unref(e).onClose();
          })
        }, {
          default: withCtx(() => [
            renderSlot(c.$slots, "default")
          ]),
          _: 3
        }, 8, ["aria-describedby", "data-state", "as", "as-child"])
      ]),
      _: 3
    }));
  }
});
var Un = defineComponent({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean, default: false },
    as: {},
    side: { default: "top" },
    sideOffset: { default: 0 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean, default: true },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    arrowPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: false }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ref(), i = Mt(), r = computed(() => {
      var p, f;
      if (e.ariaLabel)
        return e.ariaLabel;
      const u = (f = (p = useSlots()).default) == null ? void 0 : f.call(p);
      let d = "";
      function c(m) {
        typeof m.children == "string" ? d += m.children : Array.isArray(m.children) && m.children.forEach((C) => c(C));
      }
      return u == null || u.forEach((m) => c(m)), d;
    }), l = computed(() => {
      const { ariaLabel: u, ...d } = e;
      return d;
    });
    return onMounted(() => {
      et(window, "scroll", (u) => {
        const d = u.target;
        d != null && d.contains(i.trigger.value) && i.onClose();
      }), et(window, jn, i.onClose);
    }), (u, d) => (openBlock(), createBlock(unref(Be), {
      "as-child": "",
      "disable-outside-pointer-events": false,
      onEscapeKeyDown: d[0] || (d[0] = (c) => n("escapeKeyDown", c)),
      onPointerDownOutside: d[1] || (d[1] = (c) => {
        var p;
        unref(i).disableClosingTrigger.value && ((p = unref(i).trigger.value) != null && p.contains(c.target)) && c.preventDefault(), n("pointerDownOutside", c);
      }),
      onFocusOutside: d[2] || (d[2] = withModifiers(() => {
      }, ["prevent"])),
      onDismiss: d[3] || (d[3] = (c) => unref(i).onClose())
    }, {
      default: withCtx(() => [
        createVNode(unref(je), mergeProps({
          ref_key: "contentElement",
          ref: s,
          "data-state": unref(i).stateAttribute.value
        }, { ...u.$attrs, ...l.value }, { style: {
          "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
          "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
          "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
        } }), {
          default: withCtx(() => [
            renderSlot(u.$slots, "default"),
            createVNode(unref(Ge), {
              id: unref(i).contentId,
              role: "tooltip"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(r.value), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 3
        }, 16, ["data-state", "style"])
      ]),
      _: 3
    }));
  }
});
var Or = defineComponent({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = V(), { trigger: s, onClose: i } = Mt(), r = Po(), l = ref(null);
    function u() {
      l.value = null, r.onPointerInTransitChange(false);
    }
    function d(c, p) {
      const f = c.currentTarget, m = { x: c.clientX, y: c.clientY }, C = wr(m, f.getBoundingClientRect()), _ = Er(m, C), $ = xr(p.getBoundingClientRect()), E = Pr([..._, ...$]);
      l.value = E, r.onPointerInTransitChange(true);
    }
    return watchEffect((c) => {
      if (s.value && n.value) {
        const p = (m) => d(m, n.value), f = (m) => d(m, s.value);
        s.value.addEventListener("pointerleave", p), n.value.addEventListener("pointerleave", f), c(() => {
          var m, C;
          (m = s.value) == null || m.removeEventListener("pointerleave", p), (C = n.value) == null || C.removeEventListener("pointerleave", f);
        });
      }
    }), watchEffect((c) => {
      if (l.value) {
        const p = (f) => {
          var E, w;
          if (!l.value)
            return;
          const m = f.target, C = { x: f.clientX, y: f.clientY }, _ = ((E = s.value) == null ? void 0 : E.contains(m)) || ((w = n.value) == null ? void 0 : w.contains(m)), $ = !$r(C, l.value);
          _ ? u() : $ && (u(), i());
        };
        document.addEventListener("pointermove", p), c(() => document.removeEventListener("pointermove", p));
      }
    }), (c, p) => (openBlock(), createBlock(Un, mergeProps({
      ref_key: "primitiveElement",
      ref: e
    }, t), {
      default: withCtx(() => [
        renderSlot(c.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Ju = defineComponent({
  __name: "TooltipContent",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Mt(), i = ue(e, n);
    return (r, l) => unref(s).open.value ? (openBlock(), createBlock(resolveDynamicComponent(unref(s).disableHoverableContent.value ? Un : Or), normalizeProps(mergeProps({ key: 0 }, unref(i))), {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 16)) : createCommentVNode("", true);
  }
});
var Zu = defineComponent({
  __name: "TooltipArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ue), normalizeProps(guardReactiveProps(t)), null, 16));
  }
});
var Qu = defineComponent({
  __name: "TooltipPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Se), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Bo, Dr] = H("HoverCardRoot");
var ed = defineComponent({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    openDelay: { default: 700 },
    closeDelay: { default: 300 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, { openDelay: s, closeDelay: i } = toRefs(e), r = X(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), l = ref(0), u = ref(0), d = ref(false), c = ref(false);
    function p() {
      clearTimeout(u.value), l.value = window.setTimeout(() => r.value = true, s.value);
    }
    function f() {
      clearTimeout(l.value), !d.value && !c.value && (u.value = window.setTimeout(() => r.value = false, i.value));
    }
    function m() {
      r.value = false;
    }
    return Dr({
      open: r,
      onOpenChange(C) {
        r.value = C;
      },
      onOpen: p,
      onClose: f,
      onDismiss: m,
      hasSelectionRef: d,
      isPointerDownOnContentRef: c
    }), (C, _) => (openBlock(), createBlock(unref(Fe), null, {
      default: withCtx(() => [
        renderSlot(C.$slots, "default")
      ]),
      _: 3
    }));
  }
});
function wt(o) {
  return (t) => t.pointerType === "touch" ? void 0 : o();
}
function Ar(o) {
  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
var td = defineComponent({
  __name: "HoverCardTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  setup(o) {
    const t = Bo();
    return (e, n) => (openBlock(), createBlock(unref(Ve), { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          "as-child": e.asChild,
          as: e.as,
          "data-state": unref(t).open.value ? "open" : "closed",
          onPointerenter: n[0] || (n[0] = (s) => unref(wt)(unref(t).onOpen)(s)),
          onPointerleave: n[1] || (n[1] = (s) => unref(wt)(unref(t).onClose)(s)),
          onFocus: n[2] || (n[2] = (s) => unref(t).onOpen()),
          onBlur: unref(t).onClose,
          onTouchstart: withModifiers(() => {
          }, ["prevent"])
        }, {
          default: withCtx(() => [
            renderSlot(e.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "data-state", "onBlur", "onTouchstart"])
      ]),
      _: 3
    }));
  }
});
var od = defineComponent({
  __name: "HoverCardPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Se), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Ir = defineComponent({
  __name: "HoverCardContentImpl",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Tt(e), { primitiveElement: i, currentElement: r } = V(), l = Bo(), u = ref(false);
    let d;
    watchEffect((p) => {
      if (u.value) {
        const f = document.body;
        d = f.style.userSelect || f.style.webkitUserSelect, f.style.userSelect = "none", f.style.webkitUserSelect = "none", p(() => {
          f.style.userSelect = d, f.style.webkitUserSelect = d;
        });
      }
    });
    function c() {
      u.value = false, l.isPointerDownOnContentRef.value = false, nextTick(() => {
        var f;
        ((f = document.getSelection()) == null ? void 0 : f.toString()) !== "" && (l.hasSelectionRef.value = true);
      });
    }
    return onMounted(() => {
      r.value && (document.addEventListener("pointerup", c), Ar(r.value).forEach((f) => f.setAttribute("tabindex", "-1")));
    }), onUnmounted(() => {
      document.removeEventListener("pointerup", c), l.hasSelectionRef.value = false, l.isPointerDownOnContentRef.value = false;
    }), (p, f) => (openBlock(), createBlock(unref(Be), {
      "as-child": "",
      "disable-outside-pointer-events": false,
      onEscapeKeyDown: f[1] || (f[1] = (m) => n("escapeKeyDown", m)),
      onPointerDownOutside: f[2] || (f[2] = (m) => n("pointerDownOutside", m)),
      onFocusOutside: f[3] || (f[3] = withModifiers((m) => n("focusOutside", m), ["prevent"])),
      onDismiss: unref(l).onDismiss
    }, {
      default: withCtx(() => [
        createVNode(unref(je), mergeProps({
          ref_key: "primitiveElement",
          ref: i
        }, { ...unref(s), ...p.$attrs }, {
          "data-state": unref(l).open.value ? "open" : "closed",
          style: {
            userSelect: u.value ? "text" : void 0,
            // Safari requires prefix
            WebkitUserSelect: u.value ? "text" : void 0,
            // re-namespace exposed content custom properties
            "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)",
            "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)",
            "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)"
          },
          onPointerdown: f[0] || (f[0] = (m) => {
            m.currentTarget.contains(m.target) && (u.value = true), unref(l).hasSelectionRef.value = false, unref(l).isPointerDownOnContentRef.value = true;
          })
        }), {
          default: withCtx(() => [
            renderSlot(p.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "style"])
      ]),
      _: 3
    }, 8, ["onDismiss"]));
  }
});
var nd = defineComponent({
  __name: "HoverCardContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const s = ue(o, t), i = Bo();
    return (r, l) => (openBlock(), createBlock(unref(ae), {
      present: r.forceMount || unref(i).open.value
    }, {
      default: withCtx(() => [
        createVNode(Ir, mergeProps(unref(s), {
          onPointerenter: l[0] || (l[0] = (u) => unref(wt)(unref(i).onOpen)(u)),
          onPointerleave: l[1] || (l[1] = (u) => unref(wt)(unref(i).onClose)(u))
        }), {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var ad = defineComponent({
  __name: "HoverCardArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ue), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Le, Mr] = H("PopoverRoot");
var sd = defineComponent({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: false },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: false }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, { modal: s } = toRefs(e), i = X(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), r = ref(), l = ref(false);
    return Mr({
      contentId: te(),
      modal: s,
      open: i,
      onOpenChange: (u) => {
        i.value = u;
      },
      onOpenToggle: () => {
        i.value = !i.value;
      },
      triggerElement: r,
      hasCustomAnchor: l
    }), (u, d) => (openBlock(), createBlock(unref(Fe), null, {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }));
  }
});
var id = defineComponent({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o, { expose: t }) {
    const e = o, n = Le(), { primitiveElement: s, currentElement: i } = V();
    return onMounted(() => {
      n.triggerElement.value = i.value;
    }), t({ $el: i }), (r, l) => (openBlock(), createBlock(resolveDynamicComponent(unref(n).hasCustomAnchor.value ? unref(D) : unref(Ve)), { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          ref_key: "primitiveElement",
          ref: s,
          type: r.as === "button" ? "button" : void 0,
          "aria-haspopup": "dialog",
          "aria-expanded": unref(n).open.value,
          "aria-controls": unref(n).contentId,
          "data-state": unref(n).open.value ? "open" : "closed",
          as: r.as,
          "as-child": e.asChild,
          onClick: unref(n).onOpenToggle
        }, {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 8, ["type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
      ]),
      _: 3
    }));
  }
});
var rd = defineComponent({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Se), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Gn = defineComponent({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Tt(e), i = Le();
    return mo(), (r, l) => (openBlock(), createBlock(unref(At), {
      "as-child": "",
      loop: "",
      trapped: r.trapFocus,
      onMountAutoFocus: l[5] || (l[5] = (u) => n("openAutoFocus", u)),
      onUnmountAutoFocus: l[6] || (l[6] = (u) => n("closeAutoFocus", u))
    }, {
      default: withCtx(() => [
        createVNode(unref(Be), {
          "as-child": "",
          "disable-outside-pointer-events": r.disableOutsidePointerEvents,
          onPointerDownOutside: l[0] || (l[0] = (u) => n("pointerDownOutside", u)),
          onInteractOutside: l[1] || (l[1] = (u) => n("interactOutside", u)),
          onEscapeKeyDown: l[2] || (l[2] = (u) => n("escapeKeyDown", u)),
          onFocusOutside: l[3] || (l[3] = (u) => n("focusOutside", u)),
          onDismiss: l[4] || (l[4] = (u) => unref(i).onOpenChange(false))
        }, {
          default: withCtx(() => [
            createVNode(unref(je), mergeProps(unref(s), {
              id: unref(i).contentId,
              "data-state": unref(i).open.value ? "open" : "closed",
              role: "dialog",
              style: {
                "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
              }
            }), {
              default: withCtx(() => [
                renderSlot(r.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "style"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
});
var kr = defineComponent({
  __name: "PopoverContentModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Le(), i = ref(false);
    it(true);
    const r = ue(e, n), { primitiveElement: l, currentElement: u } = V();
    return rt(u), (d, c) => (openBlock(), createBlock(Gn, mergeProps({
      ref_key: "primitiveElement",
      ref: l
    }, unref(r), {
      "trap-focus": unref(s).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: c[0] || (c[0] = withModifiers(
        (p) => {
          var f;
          n("closeAutoFocus", p), i.value || (f = unref(s).triggerElement.value) == null || f.focus();
        },
        ["prevent"]
      )),
      onPointerDownOutside: c[1] || (c[1] = (p) => {
        n("pointerDownOutside", p);
        const f = p.detail.originalEvent, m = f.button === 0 && f.ctrlKey === true, C = f.button === 2 || m;
        i.value = C;
      }),
      onFocusOutside: c[2] || (c[2] = withModifiers(() => {
      }, ["prevent"]))
    }), {
      default: withCtx(() => [
        renderSlot(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
});
var Rr = defineComponent({
  __name: "PopoverContentNonModal",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Le(), i = ref(false), r = ref(false), l = ue(e, n);
    return (u, d) => (openBlock(), createBlock(Gn, mergeProps(unref(l), {
      "trap-focus": false,
      "disable-outside-pointer-events": false,
      onCloseAutoFocus: d[0] || (d[0] = (c) => {
        var p;
        n("closeAutoFocus", c), c.defaultPrevented || (i.value || (p = unref(s).triggerElement.value) == null || p.focus(), c.preventDefault()), i.value = false, r.value = false;
      }),
      onInteractOutside: d[1] || (d[1] = async (c) => {
        var m;
        n("interactOutside", c), c.defaultPrevented || (i.value = true, c.detail.originalEvent.type === "pointerdown" && (r.value = true));
        const p = c.target;
        ((m = unref(s).triggerElement.value) == null ? void 0 : m.contains(p)) && c.preventDefault(), c.detail.originalEvent.type === "focusin" && r.value && c.preventDefault();
      })
    }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var ld = defineComponent({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Le(), i = ue(e, n);
    return (r, l) => (openBlock(), createBlock(unref(ae), {
      present: r.forceMount || unref(s).open.value
    }, {
      default: withCtx(() => [
        unref(s).modal.value ? (openBlock(), createBlock(kr, normalizeProps(mergeProps({ key: 0 }, unref(i))), {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 16)) : (openBlock(), createBlock(Rr, normalizeProps(mergeProps({ key: 1 }, unref(i))), {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var ud = defineComponent({
  __name: "PopoverArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ue), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var dd = defineComponent({
  __name: "PopoverClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Le();
    return (n, s) => (openBlock(), createBlock(unref(D), {
      type: n.as === "button" ? "button" : void 0,
      as: n.as,
      "as-child": t.asChild,
      onClick: s[0] || (s[0] = (i) => unref(e).onOpenChange(false))
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "as", "as-child"]));
  }
});
var cd = defineComponent({
  __name: "PopoverAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Le();
    return onBeforeMount(() => {
      e.hasCustomAnchor.value = true;
    }), onUnmounted(() => {
      e.hasCustomAnchor.value = false;
    }), (n, s) => (openBlock(), createBlock(unref(Ve), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var kt = defineComponent({
  __name: "MenuAnchor",
  props: {
    element: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ve), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var So = defineComponent({
  __name: "MenuArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ue), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Ke, qn] = H(["MenuRoot", "MenuSub"], "MenuContext");
var [lt, Fr] = H("MenuRoot");
var To = defineComponent({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: false },
    onOpenChange: {},
    dir: {},
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, { modal: s, dir: i } = toRefs(e), r = pe(i), l = X(e, "open", n), u = ref(), d = ref(false);
    return watchEffect((c) => {
      if (!Pe)
        return;
      const p = () => {
        d.value = true, document.addEventListener("pointerdown", f, {
          capture: true,
          once: true
        }), document.addEventListener("pointermove", f, {
          capture: true,
          once: true
        });
      }, f = () => d.value = false;
      document.addEventListener("keydown", p, { capture: true }), c(() => {
        document.removeEventListener("keydown", p, { capture: true }), document.removeEventListener("pointerdown", f, {
          capture: true
        }), document.removeEventListener("pointermove", f, {
          capture: true
        });
      });
    }), qn({
      open: l,
      onOpenChange: (c) => {
        l.value = c;
      },
      content: u,
      onContentChange: (c) => {
        u.value = c;
      }
    }), Fr({
      onClose: () => {
        l.value = false;
      },
      isUsingKeyboardRef: d,
      dir: r,
      modal: s
    }), (c, p) => (openBlock(), createBlock(unref(Fe), null, {
      default: withCtx(() => [
        renderSlot(c.$slots, "default")
      ]),
      _: 3
    }));
  }
});
var [Oo, Vr] = H("MenuContent");
var Do = defineComponent({
  __name: "MenuContentImpl",
  props: mergeDefaults({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  }, {
    ...En
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Ke(), i = lt(), { trapFocus: r, disableOutsidePointerEvents: l, loop: u } = toRefs(e);
    mo(), it(l.value);
    const d = ref(""), c = ref(0), p = ref(0), f = ref(null), m = ref("right"), C = ref(0), _ = ref(null), { createCollection: $ } = ne(), { primitiveElement: E, currentElement: w } = V(), P = $(w);
    watch(w, (S) => {
      s.onContentChange(S);
    });
    const { handleTypeaheadSearch: B } = ho(P);
    onUnmounted(() => {
      window.clearTimeout(c.value);
    });
    function I(S) {
      var z, k;
      return m.value === ((z = f.value) == null ? void 0 : z.side) && Yi(S, (k = f.value) == null ? void 0 : k.area);
    }
    async function A(S) {
      n("openAutoFocus", S), S.preventDefault(), setTimeout(() => {
        var K;
        (K = w.value) == null || K.focus();
      }, 0);
    }
    function W(S) {
      if (S.defaultPrevented)
        return;
      const z = S.target.closest("[data-radix-menu-content]") === S.currentTarget, k = S.ctrlKey || S.altKey || S.metaKey, j = S.key.length === 1, ee = St(
        S,
        document.activeElement,
        w.value,
        {
          loop: u.value,
          arrowKeyOptions: "vertical",
          dir: i == null ? void 0 : i.dir.value,
          focus: true
        }
      );
      if (ee)
        return ee == null ? void 0 : ee.focus();
      if (S.code === "Space" || (z && (S.key === "Tab" && S.preventDefault(), !k && j && B(S.key)), S.target !== w.value) || !ji.includes(S.key))
        return;
      S.preventDefault();
      const ie = P.value;
      Vn.includes(S.key) && ie.reverse(), to(ie);
    }
    function F(S) {
      var K, z;
      (z = (K = S == null ? void 0 : S.currentTarget) == null ? void 0 : K.contains) != null && z.call(K, S.target) || (window.clearTimeout(c.value), d.value = "");
    }
    function N(S) {
      var k;
      if (!ot(S))
        return;
      const K = S.target, z = C.value !== S.clientX;
      if ((k = S == null ? void 0 : S.currentTarget) != null && k.contains(K) && z) {
        const j = S.clientX > C.value ? "right" : "left";
        m.value = j, C.value = S.clientX;
      }
    }
    return Vr({
      onItemEnter: (S) => {
        I(S) && S.preventDefault();
      },
      onItemLeave: (S) => {
        var K;
        I(S) || ((K = w.value) == null || K.focus(), _.value = null);
      },
      onTriggerLeave: (S) => {
        I(S) && S.preventDefault();
      },
      searchRef: d,
      pointerGraceTimerRef: p,
      onPointerGraceIntentChange: (S) => {
        f.value = S;
      }
    }), (S, K) => (openBlock(), createBlock(unref(At), {
      "as-child": "",
      trapped: unref(r),
      onMountAutoFocus: A,
      onUnmountAutoFocus: K[7] || (K[7] = (z) => n("closeAutoFocus", z))
    }, {
      default: withCtx(() => [
        createVNode(unref(Be), {
          "as-child": "",
          "disable-outside-pointer-events": unref(l),
          onEscapeKeyDown: K[2] || (K[2] = (z) => n("escapeKeyDown", z)),
          onPointerDownOutside: K[3] || (K[3] = (z) => n("pointerDownOutside", z)),
          onFocusOutside: K[4] || (K[4] = (z) => n("focusOutside", z)),
          onInteractOutside: K[5] || (K[5] = (z) => n("interactOutside", z)),
          onDismiss: K[6] || (K[6] = (z) => n("dismiss"))
        }, {
          default: withCtx(() => [
            createVNode(unref(qe), {
              "current-tab-stop-id": _.value,
              "onUpdate:currentTabStopId": K[0] || (K[0] = (z) => _.value = z),
              "as-child": "",
              orientation: "vertical",
              dir: unref(i).dir.value,
              loop: unref(u),
              onEntryFocus: K[1] || (K[1] = (z) => {
                n("entryFocus", z), unref(i).isUsingKeyboardRef.value || z.preventDefault();
              })
            }, {
              default: withCtx(() => [
                createVNode(unref(je), {
                  ref_key: "primitiveElement",
                  ref: E,
                  role: "menu",
                  as: S.as,
                  "as-child": S.asChild,
                  "aria-orientation": "vertical",
                  "data-radix-menu-content": "",
                  "data-state": unref(xo)(unref(s).open.value),
                  dir: unref(i).dir.value,
                  side: S.side,
                  "side-offset": S.sideOffset,
                  align: S.align,
                  "align-offset": S.alignOffset,
                  "avoid-collisions": S.avoidCollisions,
                  "collision-boundary": S.collisionBoundary,
                  "collision-padding": S.collisionPadding,
                  "arrow-padding": S.arrowPadding,
                  sticky: S.sticky,
                  "hide-when-detached": S.hideWhenDetached,
                  onKeydown: W,
                  onBlur: F,
                  onPointermove: N
                }, {
                  default: withCtx(() => [
                    renderSlot(S.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "sticky", "hide-when-detached"])
              ]),
              _: 3
            }, 8, ["current-tab-stop-id", "dir", "loop"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
});
var Yn = defineComponent({
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o, { expose: t }) {
    const e = o, { primitiveElement: n, currentElement: s } = V(), i = Oo(), r = ref(false);
    async function l(d) {
      if (await nextTick(), !d.defaultPrevented && ot(d)) {
        if (e.disabled)
          i.onItemLeave(d);
        else if (i.onItemEnter(d), !d.defaultPrevented) {
          const c = d.currentTarget;
          c && c.focus();
        }
      }
    }
    async function u(d) {
      await nextTick(), !d.defaultPrevented && ot(d) && i.onItemLeave(d);
    }
    return t({
      el: s
    }), (d, c) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: n,
      role: "menuitem",
      tabindex: "-1",
      as: d.as,
      "as-child": d.asChild,
      "data-radix-vue-collection-item": "",
      "aria-disabled": d.disabled || void 0,
      "data-disabled": d.disabled ? "" : void 0,
      disabled: d.disabled,
      "data-highlighted": r.value ? "" : void 0,
      onPointermove: l,
      onPointerleave: u,
      onFocus: c[0] || (c[0] = async (p) => {
        await nextTick(), !(p.defaultPrevented || d.disabled) && (r.value = true);
      }),
      onBlur: c[1] || (c[1] = async (p) => {
        await nextTick(), !p.defaultPrevented && (r.value = false);
      })
    }, {
      default: withCtx(() => [
        renderSlot(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-disabled", "data-disabled", "disabled", "data-highlighted"]));
  }
});
var ut = defineComponent({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t, { primitiveElement: s, currentElement: i } = V(), r = lt(), l = Oo(), u = ref(false);
    async function d() {
      const c = i.value;
      if (!e.disabled && c) {
        const p = new CustomEvent(Wi, {
          bubbles: true,
          cancelable: true
        });
        n("select", p), await nextTick(), p.defaultPrevented ? u.value = false : r.onClose();
      }
    }
    return (c, p) => (openBlock(), createBlock(Yn, mergeProps(e, {
      ref_key: "primitiveElement",
      ref: s,
      onClick: d,
      onPointerdown: p[0] || (p[0] = () => {
        u.value = true;
      }),
      onPointerup: p[1] || (p[1] = async (f) => {
        var m;
        await nextTick(), !f.defaultPrevented && (u.value || (m = f.currentTarget) == null || m.click());
      }),
      onKeydown: p[2] || (p[2] = async (f) => {
        const m = unref(l).searchRef.value !== "";
        c.disabled || m && f.key === " " || unref(eo).includes(f.key) && (f.currentTarget.click(), f.preventDefault());
      })
    }), {
      default: withCtx(() => [
        renderSlot(c.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Lr, Xn] = H(
  ["MenuCheckboxItem", "MenuRadioItem"],
  "MenuItemIndicatorContext"
);
var Ao = defineComponent({
  __name: "MenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = Lr({
      checked: ref(false)
    });
    return (e, n) => (openBlock(), createBlock(unref(ae), {
      present: e.forceMount || unref(_t)(unref(t).checked.value) || unref(t).checked.value === true
    }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          as: e.as,
          "as-child": e.asChild,
          "data-state": unref($o)(unref(t).checked.value)
        }, {
          default: withCtx(() => [
            renderSlot(e.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var Io = defineComponent({
  __name: "MenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String], default: false },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = X(e, "checked", n);
    return Xn({ checked: s }), (i, r) => (openBlock(), createBlock(ut, mergeProps({ role: "menuitemcheckbox" }, e, {
      "aria-checked": unref(_t)(unref(s)) ? "mixed" : unref(s),
      "data-state": unref($o)(unref(s)),
      onSelect: r[0] || (r[0] = async (l) => {
        n("select", l), unref(_t)(unref(s)) ? s.value = true : s.value = !unref(s);
      })
    }), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
});
var Kr = defineComponent({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ue(e, n), i = Ke(), { primitiveElement: r, currentElement: l } = V();
    return rt(l), (u, d) => (openBlock(), createBlock(Do, mergeProps({
      ref_key: "primitiveElement",
      ref: r
    }, unref(s), {
      "trap-focus": unref(i).open.value,
      "disable-outside-pointer-events": unref(i).open.value,
      "disable-outside-scroll": true,
      onDismiss: d[0] || (d[0] = (c) => unref(i).onOpenChange(false)),
      onFocusOutside: d[1] || (d[1] = withModifiers((c) => n("focusOutside", c), ["prevent"]))
    }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
});
var Nr = defineComponent({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = ue(o, t), i = Ke();
    return (r, l) => (openBlock(), createBlock(Do, mergeProps(unref(s), {
      "trap-focus": false,
      "disable-outside-pointer-events": false,
      "disable-outside-scroll": false,
      onDismiss: l[0] || (l[0] = (u) => unref(i).onOpenChange(false))
    }), {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Mo = defineComponent({
  __name: "MenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = ue(o, t), i = Ke(), r = lt();
    return (l, u) => (openBlock(), createBlock(unref(ae), {
      present: l.forceMount || unref(i).open.value
    }, {
      default: withCtx(() => [
        unref(r).modal.value ? (openBlock(), createBlock(Kr, normalizeProps(mergeProps({ key: 0 }, { ...l.$attrs, ...unref(s) })), {
          default: withCtx(() => [
            renderSlot(l.$slots, "default")
          ]),
          _: 3
        }, 16)) : (openBlock(), createBlock(Nr, normalizeProps(mergeProps({ key: 1 }, { ...l.$attrs, ...unref(s) })), {
          default: withCtx(() => [
            renderSlot(l.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var Rt = defineComponent({
  __name: "MenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(D), mergeProps({ role: "group" }, t), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var ko = defineComponent({
  __name: "MenuLabel",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(D), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Ro = defineComponent({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Se), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Hr, Wr] = H("MenuRadioGroup");
var Fo = defineComponent({
  __name: "MenuRadioGroup",
  props: {
    modelValue: { default: "" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "modelValue", t);
    return Wr({
      modelValue: s,
      onValueChange: (i) => {
        s.value = i;
      }
    }), (i, r) => (openBlock(), createBlock(Rt, normalizeProps(guardReactiveProps(e)), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Vo = defineComponent({
  __name: "MenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t, { value: s } = toRefs(e), i = Hr(), r = computed(
      () => i.modelValue.value === (s == null ? void 0 : s.value)
    );
    return Xn({ checked: r }), (l, u) => (openBlock(), createBlock(ut, mergeProps({ role: "menuitemradio" }, e, {
      "aria-checked": r.value,
      "data-state": unref($o)(r.value),
      onSelect: u[0] || (u[0] = async (d) => {
        n("select", d), unref(i).onValueChange(unref(s));
      })
    }), {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-checked", "data-state"]));
  }
});
var Lo = defineComponent({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Jn, zr] = H("MenuSub");
var Ko = defineComponent({
  __name: "MenuSub",
  props: {
    open: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "open", t, {
      defaultValue: false,
      passive: e.open === void 0
    }), i = Ke(), r = ref(), l = ref();
    return watchEffect((u) => {
      (i == null ? void 0 : i.open.value) === false && (s.value = false), u(() => s.value = false);
    }), qn({
      open: s,
      onOpenChange: (u) => {
        s.value = u;
      },
      content: l,
      onContentChange: (u) => {
        l.value = u;
      }
    }), zr({
      triggerId: te(),
      contentId: te(),
      trigger: r,
      onTriggerChange: (u) => {
        r.value = u;
      }
    }), (u, d) => (openBlock(), createBlock(unref(Fe), null, {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }));
  }
});
var No = defineComponent({
  __name: "MenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = ue(o, t), i = Ke(), r = lt(), l = Jn(), { primitiveElement: u, currentElement: d } = V();
    return (c, p) => (openBlock(), createBlock(unref(ae), {
      present: c.forceMount || unref(i).open.value
    }, {
      default: withCtx(() => [
        createVNode(Do, mergeProps(unref(s), {
          id: unref(l).contentId,
          ref_key: "primitiveElement",
          ref: u,
          "aria-labelledby": unref(l).triggerId,
          align: "start",
          side: unref(r).dir.value === "rtl" ? "left" : "right",
          "disable-outside-pointer-events": false,
          "disable-outside-scroll": false,
          "trap-focus": false,
          onOpenAutoFocus: p[0] || (p[0] = (f) => {
            var m;
            unref(r).isUsingKeyboardRef.value && ((m = unref(d)) == null || m.focus());
          }),
          onCloseAutoFocus: p[1] || (p[1] = withModifiers(() => {
          }, ["prevent"])),
          onFocusOutside: p[2] || (p[2] = async (f) => {
            f.defaultPrevented || f.target !== unref(l).trigger.value && unref(i).onOpenChange(false);
          }),
          onEscapeKeyDown: p[3] || (p[3] = (f) => {
            unref(r).onClose(), f.preventDefault();
          }),
          onKeydown: p[4] || (p[4] = (f) => {
            var _, $;
            const m = (_ = f.currentTarget) == null ? void 0 : _.contains(f.target), C = unref(Gi)[unref(r).dir.value].includes(f.key);
            m && C && (unref(i).onOpenChange(false), ($ = unref(l).trigger.value) == null || $.focus(), f.preventDefault());
          })
        }), {
          default: withCtx(() => [
            renderSlot(c.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "aria-labelledby", "side"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var Ho = defineComponent({
  __name: "MenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Ke(), n = lt(), s = Jn(), i = Oo(), r = ref(null), l = computed(
      () => i.pointerGraceTimerRef.value
    );
    function u() {
      r.value && window.clearTimeout(r.value), r.value = null;
    }
    onUnmounted(() => {
      u();
    });
    function d(f) {
      ot(f) && (i.onItemEnter(f), e.onOpenChange(true), !f.defaultPrevented && !t.disabled && !e.open.value && !r.value && (i.onPointerGraceIntentChange(null), r.value = window.setTimeout(() => {
        u();
      }, 100)));
    }
    function c(f) {
      var C, _;
      if (!ot(f))
        return;
      u();
      const m = (C = e.content.value) == null ? void 0 : C.getBoundingClientRect();
      if (m) {
        const $ = (_ = e.content.value) == null ? void 0 : _.dataset.side, E = $ === "right", w = E ? -5 : 5, P = m[E ? "left" : "right"], B = m[E ? "right" : "left"];
        i.onPointerGraceIntentChange({
          area: [
            // Apply a bleed on clientX to ensure that our exit point is
            // consistently within polygon bounds
            { x: f.clientX + w, y: f.clientY },
            { x: P, y: m.top },
            { x: B, y: m.top },
            { x: B, y: m.bottom },
            { x: P, y: m.bottom }
          ],
          side: $
        }), window.clearTimeout(l.value), i.pointerGraceTimerRef.value = window.setTimeout(
          () => i.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (i.onTriggerLeave(f), f.defaultPrevented)
          return;
        i.onPointerGraceIntentChange(null);
      }
    }
    async function p(f) {
      var C;
      const m = i.searchRef.value !== "";
      t.disabled || m && f.key === " " || Ui[n.dir.value].includes(f.key) && (e.onOpenChange(true), await nextTick(), (C = e.content.value) == null || C.focus(), f.preventDefault());
    }
    return (f, m) => (openBlock(), createBlock(kt, { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(Yn, {
          id: unref(s).triggerId,
          ref: (C) => {
            var _;
            (_ = unref(s)) == null || _.onTriggerChange(C == null ? void 0 : C.el);
          },
          "aria-haspopup": "menu",
          "aria-expanded": unref(e).open.value,
          "aria-controls": unref(s).contentId,
          "data-state": unref(xo)(unref(e).open.value),
          onClick: m[0] || (m[0] = async (C) => {
            t.disabled || C.defaultPrevented || (C.currentTarget.focus(), unref(e).open.value || unref(e).onOpenChange(true));
          }),
          onPointermove: d,
          onPointerleave: c,
          onKeydown: p
        }, {
          default: withCtx(() => [
            renderSlot(f.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "aria-expanded", "aria-controls", "data-state"])
      ]),
      _: 3
    }));
  }
});
var [Zn, jr] = H("DropdownMenuRoot");
var pd = defineComponent({
  __name: "DropdownMenuRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    dir: {},
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), i = ref(), { modal: r, dir: l } = toRefs(e), u = pe(l);
    return jr({
      open: s,
      onOpenChange: (d) => {
        s.value = d;
      },
      onOpenToggle: () => {
        s.value = !s.value;
      },
      triggerId: te(),
      triggerElement: i,
      contentId: te(),
      modal: r,
      dir: u
    }), (d, c) => (openBlock(), createBlock(unref(To), {
      open: unref(s),
      "onUpdate:open": c[0] || (c[0] = (p) => isRef(s) ? s.value = p : null),
      dir: unref(u),
      modal: unref(r)
    }, {
      default: withCtx(() => [
        renderSlot(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
});
var fd = defineComponent({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Zn(), { primitiveElement: n, currentElement: s } = V();
    return onMounted(() => {
      e.triggerElement = s;
    }), (i, r) => (openBlock(), createBlock(unref(kt), { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          id: unref(e).triggerId,
          ref_key: "primitiveElement",
          ref: n,
          type: i.as === "button" ? "button" : void 0,
          "as-child": t.asChild,
          as: i.as,
          "aria-haspopup": "menu",
          "aria-expanded": unref(e).open.value,
          "aria-controls": unref(e).open.value ? unref(e).contentId : void 0,
          "data-disabled": i.disabled ? "" : void 0,
          disabled: i.disabled,
          "data-state": unref(e).open.value ? "open" : "closed",
          onClick: r[0] || (r[0] = async (l) => {
            var u;
            !i.disabled && l.button === 0 && l.ctrlKey === false && ((u = unref(e)) == null || u.onOpenToggle(), await nextTick(), unref(e).open.value && l.preventDefault());
          }),
          onKeydown: r[1] || (r[1] = withKeys(
            (l) => {
              i.disabled || (["Enter", " "].includes(l.key) && unref(e).onOpenToggle(), l.key === "ArrowDown" && unref(e).onOpenChange(true), ["Enter", " ", "ArrowDown"].includes(l.key) && l.preventDefault());
            },
            ["enter", "space", "arrow-down"]
          ))
        }, {
          default: withCtx(() => [
            renderSlot(i.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
      ]),
      _: 3
    }));
  }
});
var vd = defineComponent({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ro), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var md = defineComponent({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = ue(e, n), i = Zn(), r = ref(false);
    function l(u) {
      n("closeAutoFocus", u), !u.defaultPrevented && (r.value || setTimeout(() => {
        var d;
        (d = i.triggerElement.value) == null || d.focus();
      }, 0), r.value = false, u.preventDefault());
    }
    return (u, d) => {
      var c;
      return openBlock(), createBlock(unref(Mo), mergeProps(unref(s), {
        id: unref(i).contentId,
        "aria-labelledby": (c = unref(i)) == null ? void 0 : c.triggerId,
        style: {
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        },
        onCloseAutoFocus: l,
        onInteractOutside: d[0] || (d[0] = (p) => {
          if (n("interactOutside", p), p.defaultPrevented)
            return;
          const f = p.detail.originalEvent, m = f.button === 0 && f.ctrlKey === true, C = f.button === 2 || m;
          (!unref(i).modal.value || C) && (r.value = true);
        })
      }), {
        default: withCtx(() => [
          renderSlot(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "aria-labelledby", "style"]);
    };
  }
});
var hd = defineComponent({
  __name: "DropdownMenuArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(So), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var yd = defineComponent({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(ut), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var gd = defineComponent({
  __name: "DropdownMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Rt), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var bd = defineComponent({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Lo), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Cd = defineComponent({
  __name: "DropdownMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(Io), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var _d = defineComponent({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ao), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var wd = defineComponent({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(ko), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Ed = defineComponent({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(Fo), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var xd = defineComponent({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t;
    return (s, i) => (openBlock(), createBlock(unref(Vo), normalizeProps(guardReactiveProps({ ...e, ...n })), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var $d = defineComponent({
  __name: "DropdownMenuSub",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "open", t, {
      passive: e.open === void 0,
      defaultValue: e.defaultOpen ?? false
    });
    return (i, r) => (openBlock(), createBlock(unref(Ko), {
      open: unref(s),
      "onUpdate:open": r[0] || (r[0] = (l) => isRef(s) ? s.value = l : null)
    }, {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
});
var Pd = defineComponent({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = ue(o, t);
    return (i, r) => (openBlock(), createBlock(unref(No), mergeProps(unref(s), { style: {
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
});
var Bd = defineComponent({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ho), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Qn, Ur] = H("ContextMenuRoot");
var Sd = defineComponent({
  __name: "ContextMenuRoot",
  props: {
    dir: {},
    modal: { type: Boolean, default: true }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, { dir: s, modal: i } = toRefs(e), r = pe(s), l = ref(false);
    return Ur({
      open: l,
      onOpenChange: (u) => {
        l.value = u, n("update:open", u);
      },
      dir: r,
      modal: i
    }), (u, d) => (openBlock(), createBlock(unref(To), {
      open: l.value,
      "onUpdate:open": d[0] || (d[0] = (c) => l.value = c),
      dir: unref(r),
      modal: unref(i)
    }, {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
});
function on(o) {
  return o.pointerType !== "mouse";
}
var Td = defineComponent({
  inheritAttrs: false,
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, { disabled: e } = toRefs(t), n = Qn(), s = ref({ x: 0, y: 0 }), i = computed(() => ({
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        left: s.value.x,
        right: s.value.x,
        top: s.value.y,
        bottom: s.value.y,
        ...s.value
      })
    })), r = ref(0);
    function l() {
      window.clearTimeout(r.value);
    }
    function u(f) {
      s.value = { x: f.clientX, y: f.clientY }, n.onOpenChange(true);
    }
    async function d(f) {
      e.value || (await nextTick(), f.defaultPrevented || (l(), u(f), f.preventDefault()));
    }
    async function c(f) {
      e.value || (await nextTick(), on(f) && !f.defaultPrevented && (l(), r.value = window.setTimeout(() => u(f), 700)));
    }
    async function p(f) {
      e.value || (await nextTick(), on(f) && !f.defaultPrevented && l());
    }
    return (f, m) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(kt), {
        as: "div",
        element: i.value
      }, null, 8, ["element"]),
      createVNode(unref(D), mergeProps({
        as: f.as,
        "as-child": f.asChild,
        "data-state": unref(n).open.value ? "open" : "closed",
        "data-disabled": unref(e) ? "" : void 0,
        style: {
          WebkitTouchCallout: "none"
        }
      }, f.$attrs, {
        onContextmenu: d,
        onPointerdown: c,
        onPointermove: p,
        onPointercancel: p,
        onPointerup: p
      }), {
        default: withCtx(() => [
          renderSlot(f.$slots, "default")
        ]),
        _: 3
      }, 16, ["as", "as-child", "data-state", "data-disabled"])
    ], 64));
  }
});
var Od = defineComponent({
  __name: "ContextMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ro), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Dd = defineComponent({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    alignOffset: { default: 0 },
    avoidCollisions: { type: Boolean, default: true },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: false },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Qn(), i = ref(false);
    return (r, l) => (openBlock(), createBlock(unref(Mo), mergeProps(e, {
      side: "right",
      "side-offset": 2,
      align: "start",
      style: {
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onCloseAutoFocus: l[0] || (l[0] = (u) => {
        n("closeAutoFocus", u), !u.defaultPrevented && i.value && u.preventDefault(), i.value = false;
      }),
      onInteractOutside: l[1] || (l[1] = (u) => {
        n("interactOutside", u), !u.defaultPrevented && !unref(s).modal.value && (i.value = true);
      })
    }), {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
});
var Ad = defineComponent({
  __name: "ContextMenuArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(So), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Id = defineComponent({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(ut), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Md = defineComponent({
  __name: "ContextMenuGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Rt), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var kd = defineComponent({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Lo), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Rd = defineComponent({
  __name: "ContextMenuCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(Io), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Fd = defineComponent({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ao), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Vd = defineComponent({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(ko), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Ld = defineComponent({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(Fo), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Kd = defineComponent({
  __name: "ContextMenuRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(Vo), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Nd = defineComponent({
  __name: "ContextMenuSub",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "open", t, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    });
    return (i, r) => (openBlock(), createBlock(unref(Ko), {
      open: unref(s),
      "onUpdate:open": r[0] || (r[0] = (l) => isRef(s) ? s.value = l : null)
    }, {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
});
var Hd = defineComponent({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = ue(o, t);
    return (i, r) => (openBlock(), createBlock(unref(No), mergeProps(unref(s), { style: {
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
});
var Wd = defineComponent({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ho), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Gr = ["default-value"];
var qr = defineComponent({
  __name: "BubbleSelect",
  props: {
    autocomplete: {},
    autofocus: { type: Boolean },
    disabled: { type: Boolean },
    form: {},
    multiple: { type: Boolean },
    name: {},
    required: { type: Boolean },
    size: {},
    value: {}
  },
  setup(o) {
    const t = o, { value: e } = toRefs(t);
    Xa(e);
    const n = ref();
    return (s, i) => (openBlock(), createBlock(unref(Ge), { "as-child": "" }, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("select", mergeProps({
          ref_key: "selectElement",
          ref: n
        }, t, {
          "onUpdate:modelValue": i[0] || (i[0] = (r) => isRef(e) ? e.value = r : null),
          "default-value": unref(e)
        }), [
          renderSlot(s.$slots, "default")
        ], 16, Gr), [
          [vModelSelect, unref(e)]
        ])
      ]),
      _: 3
    }));
  }
});
var Yr = {
  key: 0,
  value: ""
};
var [Te, ea] = H("SelectRoot");
var [Xr, Jr] = H("SelectRoot");
var zd = defineComponent({
  __name: "SelectRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    defaultValue: { default: "" },
    modelValue: { default: void 0 },
    orientation: { default: "vertical" },
    dir: {},
    name: {},
    autocomplete: {},
    disabled: { type: Boolean },
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:open"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = X(e, "modelValue", n, {
      defaultValue: e.defaultValue,
      passive: e.modelValue === void 0
    }), i = X(e, "open", n, {
      defaultValue: e.defaultOpen,
      passive: e.open === void 0
    }), r = ref(), l = ref(), u = ref({
      x: 0,
      y: 0
    }), d = ref(false), { required: c, disabled: p, dir: f } = toRefs(e), m = pe(f);
    ea({
      triggerElement: r,
      onTriggerChange: (E) => {
        r.value = E;
      },
      valueElement: l,
      onValueElementChange: (E) => {
        l.value = E;
      },
      valueElementHasChildren: d,
      onValueElementHasChildrenChange: (E) => {
        d.value = E;
      },
      contentId: te(),
      modelValue: s,
      onValueChange: (E) => {
        s.value = E;
      },
      open: i,
      required: c,
      onOpenChange: (E) => {
        i.value = E;
      },
      dir: m,
      triggerPointerDownPosRef: u,
      disabled: p
    });
    const C = ze(r), _ = ref(/* @__PURE__ */ new Set()), $ = computed(() => Array.from(_.value).map((E) => {
      var w;
      return (w = E.props) == null ? void 0 : w.value;
    }).join(";"));
    return Jr({
      onNativeOptionAdd: (E) => {
        _.value.add(E);
      },
      onNativeOptionRemove: (E) => {
        _.value.delete(E);
      }
    }), (E, w) => (openBlock(), createBlock(unref(Fe), null, {
      default: withCtx(() => [
        renderSlot(E.$slots, "default"),
        unref(C) ? (openBlock(), createBlock(qr, mergeProps({ key: $.value }, E.$attrs, {
          "aria-hidden": "",
          tabindex: "-1",
          required: unref(c),
          name: E.name,
          autocomplete: E.autocomplete,
          disabled: unref(p),
          value: unref(s),
          onChange: w[0] || (w[0] = (P) => s.value = P.target.value)
        }), {
          default: withCtx(() => [
            unref(s) === void 0 ? (openBlock(), createElementBlock("option", Yr)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(Array.from(_.value), (P) => (openBlock(), createBlock(resolveDynamicComponent(P), mergeProps(P.props, {
              key: P.key ?? ""
            }), null, 16))), 128))
          ]),
          _: 1
        }, 16, ["required", "name", "autocomplete", "disabled", "value"])) : createCommentVNode("", true)
      ]),
      _: 3
    }));
  }
});
var Zr = [" ", "Enter", "ArrowUp", "ArrowDown"];
var Qr = [" ", "Enter"];
var be = 10;
function ta(o) {
  return o === "" || o === void 0;
}
var jd = defineComponent({
  __name: "SelectTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = Te(), n = computed(() => {
      var f;
      return ((f = e.disabled) == null ? void 0 : f.value) || t.disabled;
    }), { primitiveElement: s, currentElement: i } = V();
    onMounted(() => {
      e.triggerElement = i;
    });
    const { injectCollection: r } = ne(), l = r(), { search: u, handleTypeaheadSearch: d, resetTypeahead: c } = ho(l);
    function p() {
      n.value || (e.onOpenChange(true), c());
    }
    return (f, m) => (openBlock(), createBlock(unref(Ve), { "as-child": "" }, {
      default: withCtx(() => {
        var C, _, $, E;
        return [
          createVNode(unref(D), {
            ref_key: "primitiveElement",
            ref: s,
            role: "combobox",
            type: f.as === "button" ? "button" : void 0,
            "aria-controls": unref(e).contentId,
            "aria-expanded": unref(e).open.value || false,
            "aria-required": (C = unref(e).required) == null ? void 0 : C.value,
            "aria-autocomplete": "none",
            disabled: f.disabled,
            dir: (_ = unref(e)) == null ? void 0 : _.dir.value,
            "data-state": ($ = unref(e)) != null && $.open.value ? "open" : "closed",
            "data-disabled": n.value ? "" : void 0,
            "data-placeholder": unref(ta)((E = unref(e).modelValue) == null ? void 0 : E.value) ? "" : void 0,
            "as-child": f.asChild,
            as: f.as,
            onClick: m[0] || (m[0] = (w) => {
              var P;
              (P = w == null ? void 0 : w.currentTarget) == null || P.focus();
            }),
            onPointerdown: m[1] || (m[1] = (w) => {
              const P = w.target;
              P.hasPointerCapture(w.pointerId) && P.releasePointerCapture(w.pointerId), w.button === 0 && w.ctrlKey === false && (p(), unref(e).triggerPointerDownPosRef.value = {
                x: Math.round(w.pageX),
                y: Math.round(w.pageY)
              }, w.preventDefault());
            }),
            onPointerup: m[2] || (m[2] = withModifiers(() => {
            }, ["prevent"])),
            onKeydown: m[3] || (m[3] = (w) => {
              const P = unref(u) !== "";
              !(w.ctrlKey || w.altKey || w.metaKey) && w.key.length === 1 && P && w.key === " " || (unref(d)(w.key), unref(Zr).includes(w.key) && (p(), w.preventDefault()));
            })
          }, {
            default: withCtx(() => [
              renderSlot(f.$slots, "default")
            ]),
            _: 3
          }, 8, ["type", "aria-controls", "aria-expanded", "aria-required", "disabled", "dir", "data-state", "data-disabled", "data-placeholder", "as-child", "as"])
        ];
      }),
      _: 3
    }));
  }
});
var Ud = defineComponent({
  __name: "SelectPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Se), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [Wo, el] = H("SelectItemAlignedPosition");
var tl = defineComponent({
  inheritAttrs: false,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["placed"],
  setup(o, { emit: t }) {
    const e = o, n = t, { injectCollection: s } = ne(), i = Te(), r = Oe(), l = s(), u = ref(false), d = ref(true), c = ref(), { primitiveElement: p, currentElement: f } = V(), { viewport: m, selectedItem: C, selectedItemText: _, focusSelectedItem: $ } = r;
    function E() {
      if (i.triggerElement.value && i.valueElement.value && c.value && f.value && (m != null && m.value) && (C != null && C.value) && (_ != null && _.value)) {
        const B = i.triggerElement.value.getBoundingClientRect(), I = f.value.getBoundingClientRect(), A = i.valueElement.value.getBoundingClientRect(), W = _.value.getBoundingClientRect();
        if (i.dir.value !== "rtl") {
          const Ae = W.left - I.left, Ee = A.left - Ae, Ie = B.left - Ee, Me = B.width + Ie, zt = Math.max(Me, I.width), jt = window.innerWidth - be, Ut = Yo(Ee, be, jt - zt);
          c.value.style.minWidth = `${Me}px`, c.value.style.left = `${Ut}px`;
        } else {
          const Ae = I.right - W.right, Ee = window.innerWidth - A.right - Ae, Ie = window.innerWidth - B.right - Ee, Me = B.width + Ie, zt = Math.max(Me, I.width), jt = window.innerWidth - be, Ut = Yo(
            Ee,
            be,
            jt - zt
          );
          c.value.style.minWidth = `${Me}px`, c.value.style.right = `${Ut}px`;
        }
        const F = l.value, N = window.innerHeight - be * 2, S = m.value.scrollHeight, K = window.getComputedStyle(f.value), z = Number.parseInt(
          K.borderTopWidth,
          10
        ), k = Number.parseInt(K.paddingTop, 10), j = Number.parseInt(
          K.borderBottomWidth,
          10
        ), ee = Number.parseInt(
          K.paddingBottom,
          10
        ), ie = z + k + S + ee + j, Ht = Math.min(
          C.value.offsetHeight * 5,
          ie
        ), qo = window.getComputedStyle(m.value), ca = Number.parseInt(qo.paddingTop, 10), pa = Number.parseInt(
          qo.paddingBottom,
          10
        ), dt = B.top + B.height / 2 - be, fa = N - dt, Wt = C.value.offsetHeight / 2, va = C.value.offsetTop + Wt, ct = z + k + va, ma = ie - ct;
        if (ct <= dt) {
          const Ae = C.value === F[F.length - 1];
          c.value.style.bottom = "0px";
          const Ee = f.value.clientHeight - m.value.offsetTop - m.value.offsetHeight, Ie = Math.max(
            fa,
            Wt + (Ae ? pa : 0) + Ee + j
          ), Me = ct + Ie;
          c.value.style.height = `${Me}px`;
        } else {
          const Ae = C.value === F[0];
          c.value.style.top = "0px";
          const Ie = Math.max(
            dt,
            z + m.value.offsetTop + (Ae ? ca : 0) + Wt
          ) + ma;
          c.value.style.height = `${Ie}px`, m.value.scrollTop = ct - dt + m.value.offsetTop;
        }
        c.value.style.margin = `${be}px 0`, c.value.style.minHeight = `${Ht}px`, c.value.style.maxHeight = `${N}px`, n("placed"), requestAnimationFrame(() => u.value = true);
      }
    }
    const w = ref("");
    onMounted(async () => {
      await nextTick(), E(), f.value && (w.value = window.getComputedStyle(f.value).zIndex);
    });
    function P(B) {
      B && d.value === true && (E(), $ == null || $(), d.value = false);
    }
    return el({
      contentWrapper: c,
      shouldExpandOnScrollRef: u,
      onScrollButtonChange: P
    }), (B, I) => (openBlock(), createElementBlock("div", {
      ref_key: "contentWrapperElement",
      ref: c,
      style: normalizeStyle({
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: w.value
      })
    }, [
      createVNode(unref(D), mergeProps({
        ref_key: "primitiveElement",
        ref: p,
        style: {
          // When we get the height of the content, it includes borders. If we were to set
          // the height without having `boxSizing: 'border-box'` it would be too big.
          boxSizing: "border-box",
          // We need to ensure the content doesn't get taller than the wrapper
          maxHeight: "100%"
        }
      }, { ...B.$attrs, ...e }), {
        default: withCtx(() => [
          renderSlot(B.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])
    ], 4));
  }
});
var ol = defineComponent({
  __name: "SelectPopperPosition",
  props: {
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: { default: be },
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const e = Tt(o);
    return (n, s) => (openBlock(), createBlock(unref(je), mergeProps(unref(e), { style: {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-select-content-available-width": "var(--radix-popper-available-width)",
      "--radix-select-content-available-height": "var(--radix-popper-available-height)",
      "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
    } }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"]));
  }
});
var Je = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
};
var [Oe, nl] = H("SelectContent");
var al = defineComponent({
  __name: "SelectContentImpl",
  props: {
    position: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: { type: Function },
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = Te();
    mo(), it(true);
    const { createCollection: i } = ne(), r = ref();
    rt(r);
    const l = i(r), { search: u, handleTypeaheadSearch: d } = ho(l), c = ref(), p = ref(), f = ref(), m = ref(false), C = ref(false);
    function _() {
      p.value && r.value && to([p.value, r.value]);
    }
    watch(m, () => {
      _();
    });
    const { onOpenChange: $, triggerPointerDownPosRef: E } = s;
    watchEffect((B) => {
      if (!r.value)
        return;
      let I = { x: 0, y: 0 };
      const A = (F) => {
        var N, S;
        I = {
          x: Math.abs(
            Math.round(F.pageX) - (((N = E.value) == null ? void 0 : N.x) ?? 0)
          ),
          y: Math.abs(
            Math.round(F.pageY) - (((S = E.value) == null ? void 0 : S.y) ?? 0)
          )
        };
      }, W = (F) => {
        var N;
        I.x <= 10 && I.y <= 10 ? F.preventDefault() : (N = r.value) != null && N.contains(F.target) || $(false), document.removeEventListener("pointermove", A), E.value = null;
      };
      E.value !== null && (document.addEventListener("pointermove", A), document.addEventListener("pointerup", W, {
        capture: true,
        once: true
      })), B(() => {
        document.removeEventListener("pointermove", A), document.removeEventListener("pointerup", W, {
          capture: true
        });
      });
    });
    function w(B) {
      const I = B.ctrlKey || B.altKey || B.metaKey;
      if (B.key === "Tab" && B.preventDefault(), !I && B.key.length === 1 && d(B.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(B.key)) {
        let A = l.value;
        if (["ArrowUp", "End"].includes(B.key) && (A = A.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(B.key)) {
          const W = B.target, F = A.indexOf(W);
          A = A.slice(F + 1);
        }
        setTimeout(() => to(A)), B.preventDefault();
      }
    }
    const P = computed(() => e.position === "popper" ? e : {});
    return nl({
      content: r,
      viewport: c,
      onViewportChange: (B) => {
        c.value = B;
      },
      itemRefCallback: (B, I, A) => {
        var N, S;
        const W = !C.value && !A;
        (((N = s.modelValue) == null ? void 0 : N.value) !== void 0 && ((S = s.modelValue) == null ? void 0 : S.value) === I || W) && (p.value = B, W && (C.value = true));
      },
      selectedItem: p,
      selectedItemText: f,
      onItemLeave: () => {
        var B;
        (B = r.value) == null || B.focus();
      },
      itemTextRefCallback: (B, I, A) => {
        var N, S;
        const W = !C.value && !A;
        (((N = s.modelValue) == null ? void 0 : N.value) !== void 0 && ((S = s.modelValue) == null ? void 0 : S.value) === I || W) && (f.value = B);
      },
      focusSelectedItem: _,
      position: e.position,
      isPositioned: m,
      searchRef: u
    }), (B, I) => (openBlock(), createBlock(unref(At), {
      "as-child": "",
      onMountAutoFocus: I[6] || (I[6] = withModifiers(() => {
      }, ["prevent"])),
      onUnmountAutoFocus: I[7] || (I[7] = (A) => {
        var W;
        n("closeAutoFocus", A), !A.defaultPrevented && ((W = unref(s).triggerElement.value) == null || W.focus({ preventScroll: true }), A.preventDefault());
      })
    }, {
      default: withCtx(() => [
        createVNode(unref(Be), {
          "as-child": "",
          "disable-outside-pointer-events": "",
          onFocusOutside: I[2] || (I[2] = withModifiers(() => {
          }, ["prevent"])),
          onDismiss: I[3] || (I[3] = (A) => unref(s).onOpenChange(false)),
          onEscapeKeyDown: I[4] || (I[4] = (A) => n("escapeKeyDown", A)),
          onPointerDownOutside: I[5] || (I[5] = (A) => n("pointerDownOutside", A))
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(
              B.position === "popper" ? ol : tl
            ), mergeProps({ ...B.$attrs, ...P.value }, {
              id: unref(s).contentId,
              ref: (A) => {
                r.value = unref(ve)(A);
              },
              role: "listbox",
              "data-state": unref(s).open.value ? "open" : "closed",
              dir: unref(s).dir.value,
              style: {
                // flex layout so we can place the scroll buttons properly
                display: "flex",
                flexDirection: "column",
                // reset the outline by default as the content MAY get focused
                outline: "none"
              },
              onContextmenu: I[0] || (I[0] = withModifiers(() => {
              }, ["prevent"])),
              onPlaced: I[1] || (I[1] = (A) => m.value = true),
              onKeydown: w
            }), {
              default: withCtx(() => [
                renderSlot(B.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "dir", "onKeydown"]))
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
});
var sl = defineComponent({
  __name: "SelectProvider",
  props: {
    context: {}
  },
  setup(o) {
    return ea(o.context), (e, n) => renderSlot(e.$slots, "default");
  }
});
var Gd = defineComponent({
  inheritAttrs: false,
  __name: "SelectContent",
  props: {
    forceMount: { type: Boolean },
    position: { default: "item-aligned" },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    onPlaced: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["closeAutoFocus", "escapeKeyDown", "pointerDownOutside"],
  setup(o, { emit: t }) {
    const s = ue(o, t), i = Te(), r = ref();
    onMounted(() => {
      r.value = new DocumentFragment();
    });
    const l = ref();
    return (u, d) => {
      var c;
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(ae), {
          ref_key: "presenceRef",
          ref: l,
          present: u.forceMount || unref(i).open.value
        }, {
          default: withCtx(() => [
            createVNode(al, normalizeProps(guardReactiveProps({ ...unref(s), ...u.$attrs })), {
              default: withCtx(() => [
                renderSlot(u.$slots, "default")
              ]),
              _: 3
            }, 16)
          ]),
          _: 3
        }, 8, ["present"]),
        !((c = l.value) != null && c.present) && r.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: r.value
        }, [
          createVNode(sl, { context: unref(i) }, {
            default: withCtx(() => [
              createBaseVNode("div", null, [
                renderSlot(u.$slots, "default")
              ])
            ]),
            _: 3
          }, 8, ["context"])
        ], 8, ["to"])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
var qd = defineComponent({
  __name: "SelectArrow",
  props: {
    width: {},
    height: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Te(), n = Oe();
    return (s, i) => unref(e).open.value && unref(n).position === "popper" ? (openBlock(), createBlock(unref(Ue), normalizeProps(mergeProps({ key: 0 }, t)), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16)) : createCommentVNode("", true);
  }
});
var Yd = defineComponent({
  __name: "SelectSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(D), mergeProps({ "aria-hidden": "" }, t), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [oa, il] = H("SelectItem");
var Xd = defineComponent({
  __name: "SelectItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { disabled: e } = toRefs(t), n = Te(), s = Oe(Je), { primitiveElement: i, currentElement: r } = V(), l = computed(() => {
      var _;
      return ((_ = n.modelValue) == null ? void 0 : _.value) === t.value;
    }), u = ref(false), d = ref(t.textValue ?? ""), c = te();
    async function p(_) {
      await nextTick(), !(_ != null && _.defaultPrevented) && (e.value || (n.onValueChange(t.value), n.onOpenChange(false)));
    }
    async function f(_) {
      var $;
      await nextTick(), !_.defaultPrevented && (e.value ? ($ = s.onItemLeave) == null || $.call(s) : _.currentTarget.focus({ preventScroll: true }));
    }
    async function m(_) {
      var $;
      await nextTick(), !_.defaultPrevented && _.currentTarget === document.activeElement && (($ = s.onItemLeave) == null || $.call(s));
    }
    async function C(_) {
      var E;
      await nextTick(), !(_.defaultPrevented || ((E = s.searchRef) == null ? void 0 : E.value) !== "" && _.key === " ") && (Qr.includes(_.key) && p(), _.key === " " && _.preventDefault());
    }
    if (t.value === "")
      throw new Error(
        "A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return onMounted(() => {
      r.value && s.itemRefCallback(
        r.value,
        t.value,
        t.disabled
      );
    }), il({
      value: t.value,
      disabled: e,
      textId: c,
      isSelected: l,
      onItemTextChange: (_) => {
        d.value = ((d.value || (_ == null ? void 0 : _.textContent)) ?? "").trim();
      }
    }), (_, $) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: i,
      role: "option",
      "data-radix-vue-collection-item": "",
      "aria-labelledby": unref(c),
      "data-highlighted": u.value ? "" : void 0,
      "aria-selected": l.value && u.value,
      "data-state": l.value ? "checked" : "unchecked",
      "aria-disabled": unref(e) || void 0,
      "data-disabled": unref(e) ? "" : void 0,
      tabindex: unref(e) ? void 0 : -1,
      as: _.as,
      "as-child": _.asChild,
      onFocus: $[0] || ($[0] = (E) => u.value = true),
      onBlur: $[1] || ($[1] = (E) => u.value = false),
      onPointerup: p,
      onPointermove: f,
      onPointerleave: m,
      onKeydown: C
    }, {
      default: withCtx(() => [
        renderSlot(_.$slots, "default")
      ]),
      _: 3
    }, 8, ["aria-labelledby", "data-highlighted", "aria-selected", "data-state", "aria-disabled", "data-disabled", "tabindex", "as", "as-child"]));
  }
});
var Jd = defineComponent({
  __name: "SelectItemIndicator",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = oa();
    return (n, s) => unref(e).isSelected.value ? (openBlock(), createBlock(unref(D), mergeProps({
      key: 0,
      "aria-hidden": ""
    }, t), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16)) : createCommentVNode("", true);
  }
});
var [rl, ll] = H("SelectGroup");
var Zd = defineComponent({
  __name: "SelectGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = te();
    return ll({ id: e }), (n, s) => (openBlock(), createBlock(unref(D), mergeProps({ role: "group" }, t, { "aria-labelledby": unref(e) }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-labelledby"]));
  }
});
var Qd = defineComponent({
  __name: "SelectLabel",
  props: {
    for: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(o) {
    const t = o, e = rl({ id: "" });
    return (n, s) => (openBlock(), createBlock(unref(D), mergeProps(t, {
      id: unref(e).id
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
});
var ec = defineComponent({
  inheritAttrs: false,
  __name: "SelectItemText",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const t = o, e = Te(), n = Oe(Je), s = Xr(), i = oa(), { primitiveElement: r, currentElement: l } = V(), u = computed(() => {
      var d;
      return h("option", {
        key: i.value,
        value: i.value,
        disabled: i.disabled.value,
        innerHTML: (d = l.value) == null ? void 0 : d.textContent
      });
    });
    return onMounted(() => {
      l.value && (i.onItemTextChange(l.value), n.itemTextRefCallback(
        l.value,
        i.value,
        i.disabled.value
      ), s.onNativeOptionAdd(u.value));
    }), onBeforeUnmount(() => {
      s.onNativeOptionRemove(u.value);
    }), (d, c) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(D), mergeProps({
        id: unref(i).textId,
        ref_key: "primitiveElement",
        ref: r
      }, { ...t, ...d.$attrs }), {
        default: withCtx(() => [
          renderSlot(d.$slots, "default")
        ]),
        _: 3
      }, 16, ["id"]),
      unref(i).isSelected.value && unref(e).valueElement.value && !unref(e).valueElementHasChildren.value ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: unref(e).valueElement.value
      }, [
        renderSlot(d.$slots, "default")
      ], 8, ["to"])) : createCommentVNode("", true)
    ], 64));
  }
});
var tc = defineComponent({
  __name: "SelectViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = Oe(Je), n = e.position === "item-aligned" ? Wo() : void 0, { primitiveElement: s, currentElement: i } = V();
    onMounted(() => {
      e == null || e.onViewportChange(i.value);
    });
    const r = ref(0);
    function l(u) {
      const d = u.currentTarget, { shouldExpandOnScrollRef: c, contentWrapper: p } = n ?? {};
      if (c != null && c.value && (p != null && p.value)) {
        const f = Math.abs(r.value - d.scrollTop);
        if (f > 0) {
          const m = window.innerHeight - be * 2, C = Number.parseFloat(
            p.value.style.minHeight
          ), _ = Number.parseFloat(p.value.style.height), $ = Math.max(C, _);
          if ($ < m) {
            const E = $ + f, w = Math.min(m, E), P = E - w;
            p.value.style.height = `${w}px`, p.value.style.bottom === "0px" && (d.scrollTop = P > 0 ? P : 0, p.value.style.justifyContent = "flex-end");
          }
        }
      }
      r.value = d.scrollTop;
    }
    return (u, d) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(D), { as: "style" }, {
        default: withCtx(() => [
          createTextVNode(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } ")
        ]),
        _: 1
      }),
      createVNode(unref(D), mergeProps({
        ref_key: "primitiveElement",
        ref: s,
        "data-radix-select-viewport": "",
        role: "presentation"
      }, { ...u.$attrs, ...t }, {
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: 1,
          overflow: "auto"
        },
        onScroll: l
      }), {
        default: withCtx(() => [
          renderSlot(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])
    ], 64));
  }
});
var na = defineComponent({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(o, { emit: t }) {
    const e = t, { injectCollection: n } = ne(), s = n(), i = Oe(Je), r = ref(null);
    function l() {
      r.value !== null && (window.clearInterval(r.value), r.value = null);
    }
    watchEffect(() => {
      const c = s.value.find(
        (p) => p === document.activeElement
      );
      c == null || c.scrollIntoView({ block: "nearest" });
    });
    function u() {
      r.value === null && (r.value = window.setInterval(() => {
        e("autoScroll");
      }, 50));
    }
    function d() {
      var c;
      (c = i.onItemLeave) == null || c.call(i), r.value === null && (r.value = window.setInterval(() => {
        e("autoScroll");
      }, 50));
    }
    return onBeforeUnmount(() => l()), (c, p) => {
      var f;
      return openBlock(), createBlock(unref(D), mergeProps({
        "aria-hidden": "",
        style: {
          flexShrink: 0
        }
      }, (f = c.$parent) == null ? void 0 : f.$props, {
        onPointerdown: u,
        onPointermove: d,
        onPointerleave: p[0] || (p[0] = () => {
          l();
        })
      }), {
        default: withCtx(() => [
          renderSlot(c.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
var oc = defineComponent({
  __name: "SelectScrollUpButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = Oe(Je), e = t.position === "item-aligned" ? Wo() : void 0, { primitiveElement: n, currentElement: s } = V(), i = ref(false);
    return watchEffect((r) => {
      var l, u;
      if ((l = t.viewport) != null && l.value && ((u = t.isPositioned) != null && u.value)) {
        let d = function() {
          i.value = c.scrollTop > 0;
        };
        const c = t.viewport.value;
        d(), c.addEventListener("scroll", d), r(() => c.removeEventListener("scroll", d));
      }
    }), watch(s, () => {
      s.value && (e == null || e.onScrollButtonChange(s.value));
    }), (r, l) => i.value ? (openBlock(), createBlock(na, {
      key: 0,
      ref_key: "primitiveElement",
      ref: n,
      onAutoScroll: l[0] || (l[0] = () => {
        const { viewport: u, selectedItem: d } = unref(t);
        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);
      })
    }, {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 512)) : createCommentVNode("", true);
  }
});
var nc = defineComponent({
  __name: "SelectScrollDownButton",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = Oe(Je), e = t.position === "item-aligned" ? Wo() : void 0, { primitiveElement: n, currentElement: s } = V(), i = ref(false);
    return watchEffect((r) => {
      var l, u;
      if ((l = t.viewport) != null && l.value && ((u = t.isPositioned) != null && u.value)) {
        let d = function() {
          const p = c.scrollHeight - c.clientHeight;
          i.value = Math.ceil(c.scrollTop) < p;
        };
        const c = t.viewport.value;
        d(), c.addEventListener("scroll", d), r(() => c.removeEventListener("scroll", d));
      }
    }), watch(s, () => {
      s.value && (e == null || e.onScrollButtonChange(s.value));
    }), (r, l) => i.value ? (openBlock(), createBlock(na, {
      key: 0,
      ref_key: "primitiveElement",
      ref: n,
      onAutoScroll: l[0] || (l[0] = () => {
        const { viewport: u, selectedItem: d } = unref(t);
        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);
      })
    }, {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 512)) : createCommentVNode("", true);
  }
});
var ac = defineComponent({
  __name: "SelectValue",
  props: {
    placeholder: { default: "" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    const { primitiveElement: t, currentElement: e } = V(), n = Te(), s = useSlots();
    return onBeforeMount(() => {
      var r;
      const i = !!Bt((r = s == null ? void 0 : s.default) == null ? void 0 : r.call(s)).length;
      n.onValueElementHasChildrenChange(i);
    }), onMounted(() => {
      n.valueElement = e;
    }), (i, r) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: t,
      as: i.as,
      "as-child": i.asChild,
      style: { pointerEvents: "none" }
    }, {
      default: withCtx(() => {
        var l;
        return [
          unref(ta)((l = unref(n).modelValue) == null ? void 0 : l.value) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(i.placeholder), 1)
          ], 64)) : renderSlot(i.$slots, "default", { key: 1 })
        ];
      }),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
var sc = defineComponent({
  __name: "SelectIcon",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(o) {
    return (t, e) => (openBlock(), createBlock(unref(D), {
      "aria-hidden": "",
      as: t.as,
      "as-child": t.asChild
    }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default", {}, () => [
          createTextVNode("▼")
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
var [Ft, ul] = H("MenubarRoot");
var ic = defineComponent({
  __name: "MenubarRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    dir: {},
    loop: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, n = t, { primitiveElement: s, currentElement: i } = V(), { createCollection: r } = ne("menubar");
    r(i);
    const l = X(e, "modelValue", n, {
      defaultValue: e.defaultValue ?? "",
      passive: e.modelValue === void 0
    }), u = ref(null), { dir: d, loop: c } = toRefs(e), p = pe(d);
    return ul({
      modelValue: l,
      dir: p,
      loop: c,
      onMenuOpen: (f) => {
        l.value = f, u.value = f;
      },
      onMenuClose: () => {
        l.value = "";
      },
      onMenuToggle: (f) => {
        l.value = l.value ? "" : f, u.value = f;
      }
    }), (f, m) => (openBlock(), createBlock(unref(qe), {
      "current-tab-stop-id": u.value,
      "onUpdate:currentTabStopId": m[0] || (m[0] = (C) => u.value = C),
      orientation: "horizontal",
      loop: unref(c),
      dir: unref(p),
      "as-child": ""
    }, {
      default: withCtx(() => [
        createVNode(unref(D), {
          ref_key: "primitiveElement",
          ref: s,
          role: "menubar"
        }, {
          default: withCtx(() => [
            renderSlot(f.$slots, "default")
          ]),
          _: 3
        }, 512)
      ]),
      _: 3
    }, 8, ["current-tab-stop-id", "loop", "dir"]));
  }
});
var [zo, dl] = H("MenubarMenu");
var rc = defineComponent({
  __name: "MenubarMenu",
  props: {
    value: {}
  },
  setup(o) {
    const e = o.value ?? te(), n = Ft(), s = ref(), i = ref(false), r = computed(() => n.modelValue.value === e);
    return watch(r, () => {
      r.value || (i.value = false);
    }), dl({
      value: e,
      triggerElement: s,
      triggerId: e,
      contentId: te(),
      wasKeyboardTriggerOpenRef: i
    }), (l, u) => (openBlock(), createBlock(unref(To), {
      open: r.value,
      modal: false,
      dir: unref(n).dir.value,
      "onUpdate:open": u[0] || (u[0] = (d) => {
        d || unref(n).onMenuClose();
      })
    }, {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir"]));
  }
});
var lc = defineComponent({
  __name: "MenubarTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = Ft(), e = zo(), { primitiveElement: n, currentElement: s } = V(), i = ref(false), r = computed(() => t.modelValue.value === e.value);
    return onMounted(() => {
      e.triggerElement = s;
    }), (l, u) => (openBlock(), createBlock(unref(Ye), {
      "as-child": "",
      focusable: !l.disabled,
      "tab-stop-id": unref(e).value
    }, {
      default: withCtx(() => [
        createVNode(unref(kt), { "as-child": "" }, {
          default: withCtx(() => [
            createVNode(unref(D), {
              id: unref(e).triggerId,
              ref_key: "primitiveElement",
              ref: n,
              as: l.as,
              type: l.as === "button" ? "button" : void 0,
              role: "menuitem",
              "aria-haspopup": "menu",
              "aria-expanded": r.value,
              "aria-controls": r.value ? unref(e).contentId : void 0,
              "data-highlighted": i.value ? "" : void 0,
              "data-state": r.value ? "open" : "closed",
              "data-disabled": l.disabled ? "" : void 0,
              disabled: l.disabled,
              "data-value": unref(e).value,
              "data-radix-vue-collection-item": "",
              onPointerdown: u[0] || (u[0] = (d) => {
                !l.disabled && d.button === 0 && d.ctrlKey === false && (unref(t).onMenuOpen(unref(e).value), r.value || d.preventDefault());
              }),
              onPointerenter: u[1] || (u[1] = () => {
                var c;
                !!unref(t).modelValue.value && !r.value && (unref(t).onMenuOpen(unref(e).value), (c = unref(s)) == null || c.focus());
              }),
              onKeydown: u[2] || (u[2] = withKeys((d) => {
                l.disabled || (["Enter", " "].includes(d.key) && unref(t).onMenuToggle(unref(e).value), d.key === "ArrowDown" && unref(t).onMenuOpen(unref(e).value), ["Enter", " ", "ArrowDown"].includes(d.key) && (unref(e).wasKeyboardTriggerOpenRef.value = true, d.preventDefault()));
              }, ["enter", "space", "arrow-down"])),
              onFocus: u[3] || (u[3] = (d) => i.value = true),
              onBlur: u[4] || (u[4] = (d) => i.value = false)
            }, {
              default: withCtx(() => [
                renderSlot(l.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "as", "type", "aria-expanded", "aria-controls", "data-highlighted", "data-state", "data-disabled", "disabled", "data-value"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["focusable", "tab-stop-id"]));
  }
});
var uc = defineComponent({
  __name: "MenubarPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ro), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var dc = defineComponent({
  __name: "MenubarContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: { default: "start" },
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = ue(o, t), i = Ft(), r = zo(), { injectCollection: l } = ne("menubar"), u = l(), d = ref(false);
    function c(p) {
      const m = p.target.hasAttribute(
        "data-radix-menubar-subtrigger"
      ), _ = (i.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft") === p.key;
      if (!_ && m)
        return;
      let E = u.value.map((B) => B.dataset.value);
      _ && E.reverse();
      const w = E.indexOf(r.value);
      E = i.loop.value ? yo(E, w + 1) : E.slice(w + 1);
      const [P] = E;
      P && i.onMenuOpen(P);
    }
    return (p, f) => (openBlock(), createBlock(unref(Mo), mergeProps({
      id: unref(r).contentId,
      "aria-labelledby": unref(r).triggerId,
      "data-radix-menubar-content": ""
    }, unref(s), {
      style: {
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onCloseAutoFocus: f[0] || (f[0] = (m) => {
        var _;
        !!!unref(i).modelValue.value && !d.value && ((_ = unref(r).triggerElement.value) == null || _.focus()), d.value = false, m.preventDefault();
      }),
      onFocusOutside: f[1] || (f[1] = (m) => {
        const C = m.target;
        unref(u).some(($) => $.contains(C)) && m.preventDefault();
      }),
      onInteractOutside: f[2] || (f[2] = (m) => {
        d.value = true;
      }),
      onOpenAutoFocus: f[3] || (f[3] = (m) => {
        unref(r).wasKeyboardTriggerOpenRef.value || m.preventDefault();
      }),
      onEntryFocus: f[4] || (f[4] = (m) => {
        unref(r).wasKeyboardTriggerOpenRef.value || m.preventDefault();
      }),
      onKeydown: withKeys(c, ["arrow-right", "arrow-left"])
    }), {
      default: withCtx(() => [
        renderSlot(p.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "aria-labelledby", "style", "onKeydown"]));
  }
});
var cc = defineComponent({
  __name: "MenubarArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(So), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var pc = defineComponent({
  __name: "MenubarItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(ut), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var fc = defineComponent({
  __name: "MenubarGroup",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Rt), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var vc = defineComponent({
  __name: "MenubarSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Lo), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var mc = defineComponent({
  __name: "MenubarCheckboxItem",
  props: {
    checked: { type: [Boolean, String] },
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select", "update:checked"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(Io), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var hc = defineComponent({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ao), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var yc = defineComponent({
  __name: "MenubarLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(ko), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var gc = defineComponent({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = le(t);
    return (i, r) => (openBlock(), createBlock(unref(Fo), normalizeProps(guardReactiveProps({ ...e, ...unref(s) })), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var bc = defineComponent({
  __name: "MenubarRadioItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t;
    return (s, i) => (openBlock(), createBlock(unref(Vo), normalizeProps(guardReactiveProps({ ...e, ...n })), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Cc = defineComponent({
  __name: "MenubarSub",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean }
  },
  emits: ["update:open"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "open", t, {
      defaultValue: e.defaultOpen ?? false,
      passive: e.open === void 0
    });
    return (i, r) => (openBlock(), createBlock(unref(Ko), {
      open: unref(s),
      "onUpdate:open": r[0] || (r[0] = (l) => isRef(s) ? s.value = l : null)
    }, {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["open"]));
  }
});
var _c = defineComponent({
  __name: "MenubarSubContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    updatePositionStrategy: {},
    prioritizePosition: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(o, { emit: t }) {
    const s = ue(o, t), { injectCollection: i } = ne("menubar"), r = Ft(), l = zo(), u = i();
    function d(c) {
      if (c.target.hasAttribute(
        "data-radix-menubar-subtrigger"
      ))
        return;
      let m = u.value.map(($) => $.dataset.value);
      const C = m.indexOf(l.value);
      m = r.loop.value ? yo(m, C + 1) : m.slice(C + 1);
      const [_] = m;
      _ && r.onMenuOpen(_);
    }
    return (c, p) => (openBlock(), createBlock(unref(No), mergeProps(unref(s), {
      "data-radix-menubar-content": "",
      style: {
        "--radix-menubar-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-menubar-content-available-width": "var(--radix-popper-available-width)",
        "--radix-menubar-content-available-height": "var(--radix-popper-available-height)",
        "--radix-menubar-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-menubar-trigger-height": "var(--radix-popper-anchor-height)"
      },
      onKeydown: withKeys(d, ["arrow-right"])
    }), {
      default: withCtx(() => [
        renderSlot(c.$slots, "default")
      ]),
      _: 3
    }, 16, ["style", "onKeydown"]));
  }
});
var wc = defineComponent({
  __name: "MenubarSubTrigger",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o;
    return (e, n) => (openBlock(), createBlock(unref(Ho), mergeProps({ "data-radix-menubar-subtrigger": "" }, t), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var [De, aa] = H(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext");
var Ec = defineComponent({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: { default: void 0 },
    defaultValue: {},
    dir: {},
    orientation: { default: "horizontal" },
    delayDuration: { default: 200 },
    skipDelayDuration: { default: 300 },
    asChild: { type: Boolean },
    as: { default: "nav" }
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "modelValue", t, {
      defaultValue: e.defaultValue ?? "",
      passive: e.modelValue === void 0
    }), i = ref(""), { primitiveElement: r, currentElement: l } = V(), u = ref(), d = ref(), { createCollection: c } = ne("nav");
    c(u);
    const { delayDuration: p, skipDelayDuration: f, dir: m } = toRefs(e), C = pe(m), _ = co(false, f), $ = computed(() => s.value !== "" || _.value ? 150 : p.value), E = po((w) => {
      i.value = s.value, s.value = w;
    }, $);
    return aa({
      isRootMenu: true,
      modelValue: s,
      previousValue: i,
      baseId: te(),
      dir: C,
      orientation: e.orientation,
      rootNavigationMenu: l,
      indicatorTrack: u,
      onIndicatorTrackChange: (w) => {
        u.value = w;
      },
      viewport: d,
      onViewportChange: (w) => {
        d.value = w;
      },
      onTriggerEnter: (w) => {
        E(w);
      },
      onTriggerLeave: () => {
        _.value = true, E("");
      },
      onContentEnter: (w) => {
        E(w);
      },
      onContentLeave: () => {
        E("");
      },
      onItemSelect: (w) => {
        i.value = s.value, s.value = w;
      },
      onItemDismiss: () => {
        i.value = s.value, s.value = "";
      }
    }), (w, P) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: r,
      "aria-label": "Main",
      as: w.as,
      "as-child": w.asChild,
      "data-orientation": w.orientation,
      dir: unref(C)
    }, {
      default: withCtx(() => [
        renderSlot(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-orientation", "dir"]));
  }
});
function Vt(o) {
  return o ? "open" : "closed";
}
function sa(o, t) {
  return `${o}-trigger-${t}`;
}
function jo(o, t) {
  return `${o}-content-${t}`;
}
var bt = "navigationMenu.rootContentDismiss";
function ao(o) {
  const t = [], e = document.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n) => {
      const s = n.tagName === "INPUT" && n.type === "hidden";
      return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; e.nextNode(); )
    t.push(e.currentNode);
  return t;
}
function ia(o) {
  const t = document.activeElement;
  return o.some((e) => e === t ? true : (e.focus(), document.activeElement !== t));
}
function cl(o) {
  return o.forEach((t) => {
    t.dataset.tabindex = t.getAttribute("tabindex") || "", t.setAttribute("tabindex", "-1");
  }), () => {
    o.forEach((t) => {
      const e = t.dataset.tabindex;
      t.setAttribute("tabindex", e);
    });
  };
}
var [Uo, pl] = H("NavigationMenuItem");
var xc = defineComponent({
  __name: "NavigationMenuItem",
  props: {
    value: {},
    asChild: { type: Boolean },
    as: { default: "li" }
  },
  setup(o) {
    const t = o, { injectCollection: e } = ne("nav"), n = e(), s = De(), i = t.value || te(), r = ref(), l = ref(), u = jo(s.baseId, i);
    let d = () => ({});
    const c = ref(false);
    async function p(_ = "start") {
      const $ = document.getElementById(u);
      if ($) {
        d();
        const E = ao($);
        E.length && ia(_ === "start" ? E : E.reverse());
      }
    }
    function f() {
      const _ = document.getElementById(u);
      if (_) {
        const $ = ao(_);
        $.length && (d = cl($));
      }
    }
    pl({
      value: i,
      contentId: u,
      triggerRef: r,
      focusProxyRef: l,
      wasEscapeCloseRef: c,
      onEntryKeyDown: p,
      onFocusProxyEnter: p,
      onContentFocusOutside: f,
      onRootContentClose: f
    });
    function m() {
      var _;
      s.onItemDismiss(), (_ = r.value) == null || _.focus();
    }
    function C(_) {
      const $ = document.activeElement;
      if (_.keyCode === 32 || _.key === "Enter")
        if (s.modelValue.value === i) {
          m(), _.preventDefault();
          return;
        } else {
          _.target.click(), _.preventDefault();
          return;
        }
      const E = n.value.filter(
        (P) => {
          var B;
          return (B = P.parentElement) == null ? void 0 : B.hasAttribute("data-menu-item");
        }
      ), w = St(_, $, void 0, {
        itemsArray: E,
        loop: false
      });
      w && (w == null || w.focus()), _.preventDefault(), _.stopPropagation();
    }
    return (_, $) => (openBlock(), createBlock(unref(D), {
      "as-child": t.asChild,
      as: _.as,
      "data-menu-item": "",
      onKeydown: withKeys(C, ["up", "down", "left", "right", "home", "end", "space"])
    }, {
      default: withCtx(() => [
        renderSlot(_.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "onKeydown"]));
  }
});
var fl = defineComponent({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, { injectCollection: s } = ne("nav"), i = s(), { primitiveElement: r, currentElement: l } = V(), u = De(), d = Uo(), c = sa(u.baseId, d.value), p = jo(u.baseId, d.value), f = ref(null), m = computed(() => {
      const B = i.value.map((S) => S.id.split("trigger-")[1]);
      u.dir.value === "rtl" && B.reverse();
      const I = B.indexOf(u.modelValue.value), A = B.indexOf(u.previousValue.value), W = d.value === u.modelValue.value, F = A === B.indexOf(d.value);
      if (!W && !F)
        return f.value;
      const N = (() => {
        if (I !== A) {
          if (W && A !== -1)
            return I > A ? "from-end" : "from-start";
          if (F && I !== -1)
            return I > A ? "to-start" : "to-end";
        }
        return null;
      })();
      return f.value = N, N;
    });
    function C(P) {
      var B, I;
      if (n("focusOutside", P), n("interactOutside", P), !P.defaultPrevented) {
        d.onContentFocusOutside();
        const A = P.target;
        (I = (B = u.rootNavigationMenu) == null ? void 0 : B.value) != null && I.contains(A) && P.preventDefault();
      }
    }
    function _(P) {
      var B;
      if (n("pointerDownOutside", P), !P.defaultPrevented) {
        const I = P.target, A = i.value.some(
          (F) => F.contains(I)
        ), W = u.isRootMenu && ((B = u.viewport.value) == null ? void 0 : B.contains(I));
        (A || W || !u.isRootMenu) && P.preventDefault();
      }
    }
    watchEffect((P) => {
      const B = l.value;
      if (u.isRootMenu && B) {
        const I = () => {
          var A;
          d.onRootContentClose(), B.contains(document.activeElement) && ((A = d.triggerRef.value) == null || A.focus());
        };
        B.addEventListener(bt, I), P(
          () => B.removeEventListener(bt, I)
        );
      }
    });
    function $(P) {
      var B, I;
      n("escapeKeyDown", P), P.defaultPrevented || (u.onItemDismiss(), (I = (B = d.triggerRef) == null ? void 0 : B.value) == null || I.focus(), d.wasEscapeCloseRef.value = true);
    }
    function E(P) {
      var F;
      const B = P.altKey || P.ctrlKey || P.metaKey, I = P.key === "Tab" && !B, A = ao(P.currentTarget);
      if (I) {
        const N = document.activeElement, S = A.findIndex(
          (k) => k === N
        ), z = P.shiftKey ? A.slice(0, S).reverse() : A.slice(S + 1, A.length);
        if (ia(z))
          P.preventDefault();
        else {
          (F = d.focusProxyRef.value) == null || F.focus();
          return;
        }
      }
      const W = St(
        P,
        document.activeElement,
        void 0,
        { itemsArray: A, loop: false }
      );
      W == null || W.focus(), !(P.key === "Enter" || P.key === "Escape") && (P.preventDefault(), P.stopPropagation());
    }
    function w() {
      var B;
      const P = new Event(bt, {
        bubbles: true,
        cancelable: true
      });
      (B = l.value) == null || B.dispatchEvent(P);
    }
    return (P, B) => (openBlock(), createBlock(unref(Be), mergeProps({
      id: unref(p),
      ref_key: "primitiveElement",
      ref: r,
      "aria-labelledby": unref(c),
      "data-motion": m.value,
      "data-state": unref(Vt)(unref(u).modelValue.value === unref(d).value),
      "data-orientation": unref(u).orientation
    }, e, {
      onKeydown: E,
      onEscapeKeyDown: $,
      onPointerDownOutside: _,
      onFocusOutside: C,
      onDismiss: w
    }), {
      default: withCtx(() => [
        renderSlot(P.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "aria-labelledby", "data-motion", "data-state", "data-orientation"]));
  }
});
var $c = defineComponent({
  inheritAttrs: false,
  __name: "NavigationMenuContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = le(n), i = Pt(), r = De(), l = Uo(), u = computed(() => l.value === r.modelValue.value), d = computed(() => !r.modelValue.value && r.previousValue.value ? r.previousValue.value === l.value : false);
    function c(p) {
      n("pointerDownOutside", p), p.preventDefault || r.onContentLeave();
    }
    return (p, f) => unref(i) ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: unref(r).viewport.value,
      disabled: !unref(r).viewport.value
    }, [
      createVNode(unref(ae), {
        present: p.forceMount || u.value || d.value
      }, {
        default: withCtx(() => [
          createVNode(fl, mergeProps({
            "data-state": unref(Vt)(u.value),
            style: {
              pointerEvents: !u.value && unref(r).isRootMenu ? "none" : void 0
            }
          }, { ...p.$attrs, ...e, ...unref(s) }, {
            onPointerenter: f[0] || (f[0] = (m) => unref(r).onContentEnter(unref(l).value)),
            onPointerleave: f[1] || (f[1] = (m) => unref(r).onContentLeave()),
            onPointerdown: c,
            onFocusOutside: f[2] || (f[2] = (m) => n("focusOutside", m)),
            onInteractOutside: f[3] || (f[3] = (m) => n("interactOutside", m))
          }), {
            default: withCtx(() => [
              renderSlot(p.$slots, "default")
            ]),
            _: 3
          }, 16, ["data-state", "style"])
        ]),
        _: 3
      }, 8, ["present"])
    ], 8, ["to", "disabled"])) : createCommentVNode("", true);
  }
});
var Pc = defineComponent({
  inheritAttrs: false,
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { injectCollection: e } = ne("nav"), n = e(), s = De(), i = ref(), r = computed(() => s.orientation === "horizontal"), l = computed(() => !!s.modelValue.value), u = ref();
    function d() {
      u.value && (i.value = {
        size: r.value ? u.value.offsetWidth : u.value.offsetHeight,
        offset: r.value ? u.value.offsetLeft : u.value.offsetTop
      });
    }
    return watchEffect(() => {
      if (!s.modelValue.value) {
        i.value = void 0;
        return;
      }
      const c = n.value;
      u.value = c.find(
        (p) => p.id.includes(s.modelValue.value)
      ), d();
    }), Ce(u, d), Ce(s.indicatorTrack, d), (c, p) => unref(s).indicatorTrack.value ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: unref(s).indicatorTrack.value
    }, [
      createVNode(unref(ae), {
        present: c.forceMount || l.value
      }, {
        default: withCtx(() => {
          var f, m, C, _;
          return [
            createVNode(unref(D), mergeProps({
              "aria-hidden": "",
              "data-state": l.value ? "visible" : "hidden",
              "data-orientation": unref(s).orientation,
              "as-child": t.asChild,
              as: c.as,
              style: {
                position: "absolute",
                ...r.value ? {
                  left: 0,
                  width: `${(f = i.value) == null ? void 0 : f.size}px`,
                  transform: `translateX(${(m = i.value) == null ? void 0 : m.offset}px)`
                } : {
                  top: 0,
                  height: `${(C = i.value) == null ? void 0 : C.size}px`,
                  transform: `translateY(${(_ = i.value) == null ? void 0 : _.offset}px)`
                }
              }
            }, c.$attrs), {
              default: withCtx(() => [
                renderSlot(c.$slots, "default")
              ]),
              _: 3
            }, 16, ["data-state", "data-orientation", "as-child", "as", "style"])
          ];
        }),
        _: 3
      }, 8, ["present"])
    ], 8, ["to"])) : createCommentVNode("", true);
  }
});
var Bc = defineComponent({
  __name: "NavigationMenuLink",
  props: {
    active: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "a" }
  },
  emits: ["select"],
  setup(o, { emit: t }) {
    const e = o, n = t;
    async function s(i) {
      var r;
      if (n("select", i), await nextTick(), !i.defaultPrevented && !i.metaKey) {
        const l = new CustomEvent(
          bt,
          {
            bubbles: true,
            cancelable: true
          }
        );
        (r = i.target) == null || r.dispatchEvent(l);
      }
    }
    return (i, r) => (openBlock(), createBlock(unref(D), {
      as: i.as,
      "data-active": i.active ? "" : void 0,
      "aria-current": i.active ? "page" : void 0,
      "as-child": e.asChild,
      "data-radix-vue-collection-item": "",
      onClick: s
    }, {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "data-active", "aria-current", "as-child"]));
  }
});
var Sc = defineComponent({
  inheritAttrs: false,
  __name: "NavigationMenuList",
  props: {
    asChild: { type: Boolean },
    as: { default: "ul" }
  },
  setup(o) {
    const t = o, e = De(), { primitiveElement: n, currentElement: s } = V();
    return onMounted(() => {
      e.onIndicatorTrackChange(s.value);
    }), (i, r) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: n,
      style: { position: "relative" }
    }, {
      default: withCtx(() => [
        createVNode(unref(D), mergeProps(i.$attrs, {
          "as-child": t.asChild,
          as: i.as,
          "data-orientation": unref(e).orientation
        }), {
          default: withCtx(() => [
            renderSlot(i.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as", "data-orientation"])
      ]),
      _: 3
    }, 512));
  }
});
var Tc = defineComponent({
  __name: "NavigationMenuSub",
  props: {
    modelValue: {},
    defaultValue: {},
    orientation: { default: "horizontal" },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(o, { emit: t }) {
    const e = o, s = X(e, "modelValue", t, {
      defaultValue: e.defaultValue ?? "",
      passive: e.modelValue === void 0
    }), i = ref(""), r = De(), { primitiveElement: l, currentElement: u } = V(), d = ref(), c = ref(), { createCollection: p } = ne("nav");
    return p(d), aa({
      ...r,
      isRootMenu: false,
      modelValue: s,
      previousValue: i,
      orientation: e.orientation,
      rootNavigationMenu: u,
      indicatorTrack: d,
      onIndicatorTrackChange: (f) => {
        d.value = f;
      },
      viewport: c,
      onViewportChange: (f) => {
        c.value = f;
      },
      onTriggerEnter: (f) => {
        s.value = f;
      },
      onTriggerLeave: () => {
      },
      onContentEnter: () => {
      },
      onContentLeave: () => {
      },
      onItemSelect: (f) => {
        s.value = f;
      },
      onItemDismiss: () => {
        s.value = "";
      }
    }), (f, m) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: l,
      "data-orientation": f.orientation,
      "as-child": e.asChild,
      as: f.as
    }, {
      default: withCtx(() => [
        renderSlot(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-orientation", "as-child", "as"]));
  }
});
var vl = ["aria-owns"];
var Oc = defineComponent({
  inheritAttrs: false,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(o) {
    const t = o, e = De(), n = Uo(), { primitiveElement: s, currentElement: i } = V(), r = ref(""), l = ref(""), u = co(false, 300), d = ref(false), c = computed(() => n.value === e.modelValue.value);
    onMounted(() => {
      n.triggerRef = i, r.value = sa(e.baseId, n.value), l.value = jo(e.baseId, n.value);
    });
    function p() {
      d.value = false, n.wasEscapeCloseRef.value = false;
    }
    function f(w) {
      if (w.pointerType === "mouse") {
        if (t.disabled || d.value || n.wasEscapeCloseRef.value || u.value)
          return;
        e.onTriggerEnter(n.value), u.value = true;
      }
    }
    function m(w) {
      if (w.pointerType === "mouse") {
        if (t.disabled)
          return;
        e.onTriggerLeave(), u.value = false;
      }
    }
    function C() {
      u.value || (c.value ? e.onItemSelect("") : e.onItemSelect(n.value), d.value = c.value);
    }
    function _(w) {
      const B = { horizontal: "ArrowDown", vertical: e.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight" }[e.orientation];
      c.value && w.key === B && (n.onEntryKeyDown(), w.preventDefault(), w.stopPropagation());
    }
    function $(w) {
      n.focusProxyRef.value = ve(w);
    }
    function E(w) {
      const P = document.getElementById(n.contentId), B = w.relatedTarget, I = B === i.value, A = P == null ? void 0 : P.contains(B);
      (I || !A) && n.onFocusProxyEnter(I ? "start" : "end");
    }
    return (w, P) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(D), mergeProps({
        id: r.value,
        ref_key: "primitiveElement",
        ref: s,
        disabled: w.disabled,
        "data-disabled": w.disabled ? "" : void 0,
        "data-state": unref(Vt)(c.value),
        "aria-expanded": c.value,
        "aria-controls": l.value,
        "as-child": t.asChild,
        as: w.as
      }, w.$attrs, {
        "data-radix-vue-collection-item": "",
        onPointerenter: p,
        onPointermove: f,
        onPointerleave: m,
        onClick: C,
        onKeydown: _
      }), {
        default: withCtx(() => [
          renderSlot(w.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "disabled", "data-disabled", "data-state", "aria-expanded", "aria-controls", "as-child", "as"]),
      c.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createVNode(unref(Ge), {
          ref: $,
          "aria-hidden": "",
          tabindex: 0,
          onFocus: E
        }),
        unref(e).viewport ? (openBlock(), createElementBlock("span", {
          key: 0,
          "aria-owns": l.value
        }, null, 8, vl)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true)
    ], 64));
  }
});
var Dc = defineComponent({
  inheritAttrs: false,
  __name: "NavigationMenuViewport",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const { primitiveElement: t, currentElement: e } = V(), n = De(), s = ref(), i = computed(() => !!n.modelValue.value), r = computed(() => n.modelValue.value);
    watch(e, () => {
      e.value && n.onViewportChange(e.value);
    });
    const l = ref();
    return watch([r, i], async () => {
      var d, c;
      if (await nextTick(), !e.value)
        return;
      const u = (c = (d = e.value.querySelector("[data-state=open]")) == null ? void 0 : d.children) == null ? void 0 : c[0];
      l.value = u;
    }, { immediate: true }), Ce(l, () => {
      l.value && (s.value = {
        width: l.value.offsetWidth,
        height: l.value.offsetHeight
      });
    }), (u, d) => (openBlock(), createBlock(unref(ae), {
      present: u.forceMount || i.value
    }, {
      default: withCtx(() => {
        var c, p;
        return [
          createVNode(unref(D), mergeProps(u.$attrs, {
            ref_key: "primitiveElement",
            ref: t,
            as: u.as,
            "as-child": u.asChild,
            "data-state": unref(Vt)(i.value),
            "data-orientation": unref(n).orientation,
            style: {
              // Prevent interaction when animating out
              pointerEvents: !i.value && unref(n).isRootMenu ? "none" : void 0,
              "--radix-navigation-menu-viewport-width": s.value ? `${(c = s.value) == null ? void 0 : c.width}px` : void 0,
              "--radix-navigation-menu-viewport-height": s.value ? `${(p = s.value) == null ? void 0 : p.height}px` : void 0
            },
            onPointerenter: d[0] || (d[0] = (f) => unref(n).onContentEnter(unref(n).modelValue.value)),
            onPointerleave: d[1] || (d[1] = (f) => unref(n).onContentLeave())
          }), {
            default: withCtx(() => [
              renderSlot(u.$slots, "default")
            ]),
            _: 3
          }, 16, ["as", "as-child", "data-state", "data-orientation", "style"])
        ];
      }),
      _: 3
    }, 8, ["present"]));
  }
});
var [me, ml] = H("ScrollAreaRoot");
var Ac = defineComponent({
  __name: "ScrollAreaRoot",
  props: {
    type: { default: "hover" },
    dir: {},
    scrollHideDelay: { default: 600 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, { primitiveElement: e, currentElement: n } = V(), s = ref(0), i = ref(0), r = ref(), l = ref(), u = ref(), d = ref(), c = ref(false), p = ref(false), { type: f, dir: m, scrollHideDelay: C } = toRefs(t), _ = pe(m);
    return ml({
      type: f,
      dir: _,
      scrollHideDelay: C,
      scrollArea: n,
      viewport: r,
      onViewportChange: ($) => {
        r.value = $ || void 0;
      },
      content: l,
      onContentChange: ($) => {
        l.value = $;
      },
      scrollbarX: u,
      scrollbarXEnabled: c,
      scrollbarY: d,
      scrollbarYEnabled: p,
      onScrollbarXChange: ($) => {
        u.value = $ || void 0;
      },
      onScrollbarYChange: ($) => {
        d.value = $ || void 0;
      },
      onScrollbarXEnabledChange: ($) => {
        c.value = $;
      },
      onScrollbarYEnabledChange: ($) => {
        p.value = $;
      },
      onCornerWidthChange: ($) => {
        s.value = $;
      },
      onCornerHeightChange: ($) => {
        i.value = $;
      }
    }), ($, E) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: e,
      "as-child": t.asChild,
      as: $.as,
      dir: unref(_),
      style: normalizeStyle({
        position: "relative",
        // Pass corner sizes as CSS vars to reduce re-renders of context consumers
        "--radix-scroll-area-corner-width": `${s.value}px`,
        "--radix-scroll-area-corner-height": `${i.value}px`
      })
    }, {
      default: withCtx(() => [
        renderSlot($.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "dir", "style"]));
  }
});
var Ic = defineComponent({
  inheritAttrs: false,
  __name: "ScrollAreaViewport",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = me(), { primitiveElement: n, currentElement: s } = V(), i = ref();
    return onMounted(() => {
      e.onViewportChange(i.value), e.onContentChange(s.value);
    }), (r, l) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(D), { as: "style" }, {
        default: withCtx(() => [
          createTextVNode(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")
        ]),
        _: 1
      }),
      createBaseVNode("div", mergeProps({
        ref_key: "viewportElement",
        ref: i,
        "data-radix-scroll-area-viewport": "",
        style: {
          /**
           * We don't support `visible` because the intention is to have at least one scrollbar
           * if this component is used and `visible` will behave like `auto` in that case
           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
           *
           * We don't handle `auto` because the intention is for the native implementation
           * to be hidden if using this component. We just want to ensure the node is scrollable
           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
           * the browser from having to work out whether to render native scrollbars or not,
           * we tell it to with the intention of hiding them in CSS.
           */
          overflowX: unref(e).scrollbarXEnabled.value ? "scroll" : "hidden",
          overflowY: unref(e).scrollbarYEnabled.value ? "scroll" : "hidden"
        }
      }, r.$attrs, { tabindex: 0 }), [
        createVNode(unref(D), {
          ref_key: "primitiveElement",
          ref: n,
          style: { minWidth: "100%", display: "table" },
          "as-child": t.asChild,
          as: r.as
        }, {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ], 16)
    ], 64));
  }
});
function hl(o, [t, e]) {
  return Math.min(e, Math.max(t, o));
}
function ra(o, t) {
  return (e) => {
    if (o[0] === o[1] || t[0] === t[1])
      return t[0];
    const n = (t[1] - t[0]) / (o[1] - o[0]);
    return t[0] + n * (e - o[0]);
  };
}
function Lt(o) {
  const t = la(o.viewport, o.content), e = o.scrollbar.paddingStart + o.scrollbar.paddingEnd, n = (o.scrollbar.size - e) * t;
  return Math.max(n, 18);
}
function la(o, t) {
  const e = o / t;
  return Number.isNaN(e) ? 0 : e;
}
function yl(o, t = () => {
}) {
  let e = { left: o.scrollLeft, top: o.scrollTop }, n = 0;
  return function s() {
    const i = { left: o.scrollLeft, top: o.scrollTop }, r = e.left !== i.left, l = e.top !== i.top;
    (r || l) && t(), e = i, n = window.requestAnimationFrame(s);
  }(), () => window.cancelAnimationFrame(n);
}
function nn(o, t, e = "ltr") {
  const n = Lt(t), s = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, i = t.scrollbar.size - s, r = t.content - t.viewport, l = i - n, u = e === "ltr" ? [0, r] : [r * -1, 0], d = hl(
    o,
    u
  );
  return ra([0, r], [0, l])(d);
}
function yt(o) {
  return o ? Number.parseInt(o, 10) : 0;
}
function gl(o, t, e, n = "ltr") {
  const s = Lt(e), i = s / 2, r = t || i, l = s - r, u = e.scrollbar.paddingStart + r, d = e.scrollbar.size - e.scrollbar.paddingEnd - l, c = e.content - e.viewport, p = n === "ltr" ? [0, c] : [c * -1, 0];
  return ra(
    [u, d],
    p
  )(o);
}
function an(o, t) {
  return o > 0 && o < t;
}
var ua = defineComponent({
  __name: "ScrollAreaScrollbarImpl",
  props: {
    isHorizontal: { type: Boolean }
  },
  emits: ["onDragScroll", "onWheelScroll", "onThumbPointerDown"],
  setup(o, { emit: t }) {
    const e = o, n = t, s = me(), i = Kt(), r = Nt(), { primitiveElement: l, currentElement: u } = V(), d = _e(), c = ref(""), p = ref();
    function f(w) {
      var P, B;
      if (p.value) {
        const I = w.clientX - ((P = p.value) == null ? void 0 : P.left), A = w.clientY - ((B = p.value) == null ? void 0 : B.top);
        n("onDragScroll", { x: I, y: A });
      }
    }
    function m(w) {
      w.button === 0 && (w.target.setPointerCapture(w.pointerId), p.value = u.value.getBoundingClientRect(), c.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", s.viewport && (s.viewport.value.style.scrollBehavior = "auto"), f(w));
    }
    function C(w) {
      f(w);
    }
    function _(w) {
      const P = w.target;
      P.hasPointerCapture(w.pointerId) && P.releasePointerCapture(w.pointerId), document.body.style.webkitUserSelect = c.value, s.viewport && (s.viewport.value.style.scrollBehavior = ""), p.value = void 0;
    }
    function $(w) {
      var A;
      const P = w.target, B = (A = u.value) == null ? void 0 : A.contains(P), I = i.sizes.value.content - i.sizes.value.viewport;
      B && i.handleWheelScroll(w, I);
    }
    onMounted(() => {
      document.addEventListener("wheel", $, { passive: false });
    }), onUnmounted(() => {
      document.removeEventListener("wheel", $);
    });
    function E() {
      var w, P, B, I, A;
      u.value && (e.isHorizontal ? i.handleSizeChange({
        content: ((w = s.viewport.value) == null ? void 0 : w.scrollWidth) ?? 0,
        viewport: ((P = s.viewport.value) == null ? void 0 : P.offsetWidth) ?? 0,
        scrollbar: {
          size: u.value.clientWidth ?? 0,
          paddingStart: yt(getComputedStyle(u.value).paddingLeft),
          paddingEnd: yt(getComputedStyle(u.value).paddingRight)
        }
      }) : i.handleSizeChange({
        content: ((B = s.viewport.value) == null ? void 0 : B.scrollHeight) ?? 0,
        viewport: ((I = s.viewport.value) == null ? void 0 : I.offsetHeight) ?? 0,
        scrollbar: {
          size: ((A = u.value) == null ? void 0 : A.clientHeight) ?? 0,
          paddingStart: yt(getComputedStyle(u.value).paddingLeft),
          paddingEnd: yt(getComputedStyle(u.value).paddingRight)
        }
      }));
    }
    return Ce(u, E), Ce(s.content, E), (w, P) => (openBlock(), createBlock(unref(D), {
      ref: (B) => {
        unref(d)(B), l.value = B;
      },
      style: { position: "absolute" },
      "data-scrollbarimpl": "",
      as: unref(r).as.value,
      "as-child": unref(r).asChild.value,
      onPointerdown: m,
      onPointermove: C,
      onPointerup: _
    }, {
      default: withCtx(() => [
        renderSlot(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
});
var bl = defineComponent({
  __name: "ScrollAreaScrollbarX",
  setup(o) {
    const t = me(), e = Kt(), { primitiveElement: n, currentElement: s } = V(), i = _e();
    onMounted(() => {
      s.value && t.onScrollbarXChange(s.value);
    });
    const r = computed(() => e.sizes.value);
    return (l, u) => (openBlock(), createBlock(ua, {
      ref: (d) => {
        unref(i)(d), n.value = d;
      },
      "is-horizontal": true,
      "data-orientation": "horizontal",
      style: normalizeStyle({
        bottom: 0,
        left: unref(t).dir.value === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: unref(t).dir.value === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": r.value ? `${unref(Lt)(r.value)}px` : void 0
      }),
      onOnDragScroll: u[0] || (u[0] = (d) => unref(e).onDragScroll(d.x))
    }, {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
});
var Cl = defineComponent({
  __name: "ScrollAreaScrollbarY",
  setup(o) {
    const t = me(), e = Kt(), { primitiveElement: n, currentElement: s } = V(), i = _e();
    onMounted(() => {
      s.value && t.onScrollbarYChange(s.value);
    });
    const r = computed(() => e.sizes.value);
    return (l, u) => (openBlock(), createBlock(ua, {
      ref: (d) => {
        unref(i)(d), n.value = d;
      },
      "is-horizontal": false,
      "data-orientation": "vertical",
      style: normalizeStyle({
        top: 0,
        right: unref(t).dir.value === "ltr" ? 0 : void 0,
        left: unref(t).dir.value === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": r.value ? `${unref(Lt)(r.value)}px` : void 0
      }),
      onOnDragScroll: u[0] || (u[0] = (d) => unref(e).onDragScroll(d.y))
    }, {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
});
var [Kt, _l] = H("ScrollAreaScrollbarVisible");
var Go = defineComponent({
  __name: "ScrollAreaScrollbarVisible",
  setup(o) {
    const t = me(), e = Nt(), n = _e(), s = ref({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    }), i = computed(() => {
      const E = la(s.value.viewport, s.value.content);
      return E > 0 && E < 1;
    }), r = ref(), l = ref(0);
    function u(E, w) {
      if (m.value) {
        const P = t.viewport.value.scrollLeft + E.deltaY;
        t.viewport.value.scrollLeft = P, an(P, w) && E.preventDefault();
      } else {
        const P = t.viewport.value.scrollTop + E.deltaY;
        t.viewport.value.scrollTop = P, an(P, w) && E.preventDefault();
      }
    }
    function d(E, w) {
      m.value ? l.value = w.x : l.value = w.y;
    }
    function c(E) {
      l.value = 0;
    }
    function p(E) {
      s.value = E;
    }
    function f(E, w) {
      return gl(
        E,
        l.value,
        s.value,
        w
      );
    }
    const m = computed(
      () => e.isHorizontal.value
    );
    function C(E) {
      m.value ? t.viewport.value.scrollLeft = f(
        E,
        t.dir.value
      ) : t.viewport.value.scrollTop = f(E);
    }
    function _() {
      if (m.value) {
        if (t.viewport.value && r.value) {
          const E = t.viewport.value.scrollLeft, w = nn(
            E,
            s.value,
            t.dir.value
          );
          r.value.style.transform = `translate3d(${w}px, 0, 0)`;
        }
      } else if (t.viewport.value && r.value) {
        const E = t.viewport.value.scrollTop, w = nn(E, s.value);
        r.value.style.transform = `translate3d(0, ${w}px, 0)`;
      }
    }
    function $(E) {
      r.value = E;
    }
    return _l({
      sizes: s,
      hasThumb: i,
      handleWheelScroll: u,
      handleThumbDown: d,
      handleThumbUp: c,
      handleSizeChange: p,
      onThumbPositionChange: _,
      onThumbChange: $,
      onDragScroll: C
    }), (E, w) => m.value ? (openBlock(), createBlock(bl, mergeProps({ key: 0 }, E.$attrs, {
      ref_key: "forwardRef",
      ref: n
    }), {
      default: withCtx(() => [
        renderSlot(E.$slots, "default")
      ]),
      _: 3
    }, 16)) : (openBlock(), createBlock(Cl, mergeProps({ key: 1 }, E.$attrs, {
      ref_key: "forwardRef",
      ref: n
    }), {
      default: withCtx(() => [
        renderSlot(E.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var da = defineComponent({
  __name: "ScrollAreaScrollbarAuto",
  props: {
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = me(), e = Nt(), n = _e(), s = ref(false), i = po(() => {
      if (t.viewport.value) {
        const r = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, l = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;
        s.value = e.isHorizontal.value ? r : l;
      }
    }, 10);
    return onMounted(() => i()), Ce(t.viewport, i), Ce(t.content, i), (r, l) => (openBlock(), createBlock(unref(ae), {
      present: r.forceMount || s.value
    }, {
      default: withCtx(() => [
        createVNode(Go, mergeProps(r.$attrs, {
          ref_key: "forwardRef",
          ref: n,
          "data-state": s.value ? "visible" : "hidden"
        }), {
          default: withCtx(() => [
            renderSlot(r.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var wl = defineComponent({
  inheritAttrs: false,
  __name: "ScrollAreaScrollbarHover",
  props: {
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = me(), e = _e();
    let n;
    const s = ref(false);
    function i() {
      window.clearTimeout(n), s.value = true;
    }
    function r() {
      n = window.setTimeout(() => {
        s.value = false;
      }, t.scrollHideDelay.value);
    }
    return onMounted(() => {
      const l = t.scrollArea.value;
      l && (l.addEventListener("pointerenter", i), l.addEventListener("pointerleave", r));
    }), onUnmounted(() => {
      const l = t.scrollArea.value;
      l && (window.clearTimeout(n), l.removeEventListener("pointerenter", i), l.removeEventListener("pointerleave", r));
    }), (l, u) => (openBlock(), createBlock(unref(ae), {
      present: l.forceMount || s.value
    }, {
      default: withCtx(() => [
        createVNode(da, mergeProps(l.$attrs, {
          ref_key: "forwardRef",
          ref: e,
          "data-state": s.value ? "visible" : "hidden"
        }), {
          default: withCtx(() => [
            renderSlot(l.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var El = defineComponent({
  __name: "ScrollAreaScrollbarScroll",
  props: {
    forceMount: { type: Boolean }
  },
  setup(o) {
    const t = me(), e = Nt(), n = _e(), { state: s, dispatch: i } = gn("hidden", {
      hidden: {
        SCROLL: "scrolling"
      },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    watchEffect(() => {
      s.value === "idle" && window.setTimeout(
        () => i("HIDE"),
        t.scrollHideDelay.value
      );
    });
    const r = po(() => i("SCROLL_END"), 100);
    return watchEffect(() => {
      const l = t.viewport.value, u = e.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (l) {
        let d = l[u];
        const c = () => {
          const p = l[u];
          d !== p && (i("SCROLL"), r()), d = p;
        };
        l.addEventListener("scroll", c);
      }
    }), (l, u) => (openBlock(), createBlock(unref(ae), {
      present: l.forceMount || unref(s) !== "hidden"
    }, {
      default: withCtx(() => [
        createVNode(Go, mergeProps(l.$attrs, {
          ref_key: "forwardRef",
          ref: n
        }), {
          default: withCtx(() => [
            renderSlot(l.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
var [Nt, xl] = H("ScrollAreaScrollbar");
var Mc = defineComponent({
  inheritAttrs: false,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: { default: "vertical" },
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(o) {
    const t = o, e = me(), n = computed(() => t.orientation === "horizontal");
    watch(
      n,
      () => {
        n.value ? e.onScrollbarXEnabledChange(true) : e.onScrollbarYEnabledChange(true);
      },
      { immediate: true }
    ), onUnmounted(() => {
      e.onScrollbarXEnabledChange(false), e.onScrollbarYEnabledChange(false);
    });
    const { orientation: s, forceMount: i, asChild: r, as: l } = toRefs(t);
    return xl({
      orientation: s,
      forceMount: i,
      isHorizontal: n,
      as: l,
      asChild: r
    }), (u, d) => unref(e).type.value === "hover" ? (openBlock(), createBlock(wl, mergeProps({ key: 0 }, u.$attrs, { "force-mount": unref(i) }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : unref(e).type.value === "scroll" ? (openBlock(), createBlock(El, mergeProps({ key: 1 }, u.$attrs, { "force-mount": unref(i) }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : unref(e).type.value === "auto" ? (openBlock(), createBlock(da, mergeProps({ key: 2 }, u.$attrs, { "force-mount": unref(i) }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["force-mount"])) : unref(e).type.value === "always" ? (openBlock(), createBlock(Go, mergeProps({ key: 3 }, u.$attrs, { "data-state": "visible" }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16)) : createCommentVNode("", true);
  }
});
var kc = defineComponent({
  __name: "ScrollAreaThumb",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = me(), n = Kt();
    function s(f) {
      const C = f.target.getBoundingClientRect(), _ = f.clientX - C.left, $ = f.clientY - C.top;
      n.handleThumbDown(f, { x: _, y: $ });
    }
    function i(f) {
      n.handleThumbUp(f);
    }
    const { primitiveElement: r, currentElement: l } = V(), u = ref(), d = computed(() => e.viewport.value);
    function c() {
      if (!u.value) {
        const f = yl(
          d.value,
          n.onThumbPositionChange
        );
        u.value = f, n.onThumbPositionChange();
      }
    }
    const p = computed(() => n.sizes.value);
    return ja(p, () => {
      n.onThumbChange(l.value), d.value && (n.onThumbPositionChange(), d.value.addEventListener("scroll", c));
    }), onUnmounted(() => {
      var f;
      d.value.removeEventListener("scroll", c), (f = e.viewport.value) == null || f.removeEventListener("scroll", c);
    }), (f, m) => (openBlock(), createBlock(unref(D), {
      ref_key: "primitiveElement",
      ref: r,
      "data-state": unref(n).hasThumb ? "visible" : "hidden",
      style: normalizeStyle({
        width: "var(--radix-scroll-area-thumb-width)",
        height: "var(--radix-scroll-area-thumb-height)"
      }),
      "as-child": t.asChild,
      as: f.as,
      onPointerdown: s,
      onPointerup: i
    }, {
      default: withCtx(() => [
        renderSlot(f.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-state", "style", "as-child", "as"]));
  }
});
var $l = defineComponent({
  __name: "ScrollAreaCornerImpl",
  setup(o) {
    const t = me(), e = ref(0), n = ref(0), s = computed(() => !!e.value && !!n.value);
    function i() {
      var u;
      const l = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;
      t.onCornerHeightChange(l), n.value = l;
    }
    function r() {
      var u;
      const l = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;
      t.onCornerWidthChange(l), e.value = l;
    }
    return Ce(t.scrollbarX.value, i), Ce(t.scrollbarY.value, r), watch(() => t.scrollbarX.value, i), watch(() => t.scrollbarY.value, r), (l, u) => {
      var d;
      return s.value ? (openBlock(), createBlock(unref(D), mergeProps({
        key: 0,
        style: {
          width: `${e.value}px`,
          height: `${n.value}px`,
          position: "absolute",
          right: unref(t).dir.value === "ltr" ? 0 : void 0,
          left: unref(t).dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      }, (d = l.$parent) == null ? void 0 : d.$props), {
        default: withCtx(() => [
          renderSlot(l.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"])) : createCommentVNode("", true);
    };
  }
});
var Rc = defineComponent({
  __name: "ScrollAreaCorner",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(o) {
    const t = o, e = me(), n = computed(
      () => !!e.scrollbarX.value && !!e.scrollbarY.value
    ), s = computed(
      () => e.type.value !== "scroll" && n.value
    );
    return (i, r) => s.value ? (openBlock(), createBlock($l, normalizeProps(mergeProps({ key: 0 }, t)), {
      default: withCtx(() => [
        renderSlot(i.$slots, "default")
      ]),
      _: 3
    }, 16)) : createCommentVNode("", true);
  }
});
export {
  Al as AccordionContent,
  Il as AccordionHeader,
  Dl as AccordionItem,
  Ol as AccordionRoot,
  Ml as AccordionTrigger,
  Iu as AlertDialogAction,
  Ou as AlertDialogCancel,
  Su as AlertDialogContent,
  Au as AlertDialogDescription,
  Tu as AlertDialogOverlay,
  Bu as AlertDialogPortal,
  $u as AlertDialogRoot,
  Du as AlertDialogTitle,
  Pu as AlertDialogTrigger,
  ou as AspectRatio,
  Gu as AvatarFallback,
  Uu as AvatarImage,
  ju as AvatarRoot,
  Rl as CheckboxIndicator,
  kl as CheckboxRoot,
  vs as CollapsibleContent,
  cs as CollapsibleRoot,
  ps as CollapsibleTrigger,
  Ll as ComboboxAnchor,
  Xl as ComboboxArrow,
  Nl as ComboboxCancel,
  zl as ComboboxContent,
  jl as ComboboxEmpty,
  Hl as ComboboxGroup,
  Vl as ComboboxInput,
  Gl as ComboboxItem,
  ql as ComboboxItemIndicator,
  Wl as ComboboxLabel,
  Jl as ComboboxPortal,
  Fl as ComboboxRoot,
  Yl as ComboboxSeparator,
  Kl as ComboboxTrigger,
  Ul as ComboboxViewport,
  Tl as ConfigProvider,
  Ad as ContextMenuArrow,
  Rd as ContextMenuCheckboxItem,
  Dd as ContextMenuContent,
  Md as ContextMenuGroup,
  Id as ContextMenuItem,
  Fd as ContextMenuItemIndicator,
  Vd as ContextMenuLabel,
  Od as ContextMenuPortal,
  Ld as ContextMenuRadioGroup,
  Kd as ContextMenuRadioItem,
  Sd as ContextMenuRoot,
  kd as ContextMenuSeparator,
  Nd as ContextMenuSub,
  Hd as ContextMenuSubContent,
  Wd as ContextMenuSubTrigger,
  Td as ContextMenuTrigger,
  Kn as DialogClose,
  Qi as DialogContent,
  nr as DialogDescription,
  tr as DialogOverlay,
  xu as DialogPortal,
  ki as DialogRoot,
  or as DialogTitle,
  Ri as DialogTrigger,
  hd as DropdownMenuArrow,
  Cd as DropdownMenuCheckboxItem,
  md as DropdownMenuContent,
  gd as DropdownMenuGroup,
  yd as DropdownMenuItem,
  _d as DropdownMenuItemIndicator,
  wd as DropdownMenuLabel,
  vd as DropdownMenuPortal,
  Ed as DropdownMenuRadioGroup,
  xd as DropdownMenuRadioItem,
  pd as DropdownMenuRoot,
  bd as DropdownMenuSeparator,
  $d as DropdownMenuSub,
  Pd as DropdownMenuSubContent,
  Bd as DropdownMenuSubTrigger,
  fd as DropdownMenuTrigger,
  ad as HoverCardArrow,
  nd as HoverCardContent,
  od as HoverCardPortal,
  ed as HoverCardRoot,
  td as HoverCardTrigger,
  tu as Label,
  cc as MenubarArrow,
  mc as MenubarCheckboxItem,
  dc as MenubarContent,
  fc as MenubarGroup,
  pc as MenubarItem,
  hc as MenubarItemIndicator,
  yc as MenubarLabel,
  rc as MenubarMenu,
  uc as MenubarPortal,
  gc as MenubarRadioGroup,
  bc as MenubarRadioItem,
  ic as MenubarRoot,
  vc as MenubarSeparator,
  Cc as MenubarSub,
  _c as MenubarSubContent,
  wc as MenubarSubTrigger,
  lc as MenubarTrigger,
  $c as NavigationMenuContent,
  Pc as NavigationMenuIndicator,
  xc as NavigationMenuItem,
  Bc as NavigationMenuLink,
  Sc as NavigationMenuList,
  Ec as NavigationMenuRoot,
  Tc as NavigationMenuSub,
  Oc as NavigationMenuTrigger,
  Dc as NavigationMenuViewport,
  mu as PaginationEllipsis,
  hu as PaginationFirst,
  yu as PaginationLast,
  gu as PaginationList,
  bu as PaginationListItem,
  Cu as PaginationNext,
  _u as PaginationPrev,
  vu as PaginationRoot,
  cd as PopoverAnchor,
  ud as PopoverArrow,
  dd as PopoverClose,
  ld as PopoverContent,
  rd as PopoverPortal,
  sd as PopoverRoot,
  id as PopoverTrigger,
  D as Primitive,
  Eu as ProgressIndicator,
  wu as ProgressRoot,
  fu as RadioGroupIndicator,
  pu as RadioGroupItem,
  cu as RadioGroupRoot,
  Rc as ScrollAreaCorner,
  Ac as ScrollAreaRoot,
  Mc as ScrollAreaScrollbar,
  kc as ScrollAreaThumb,
  Ic as ScrollAreaViewport,
  qd as SelectArrow,
  Gd as SelectContent,
  Zd as SelectGroup,
  sc as SelectIcon,
  Xd as SelectItem,
  Jd as SelectItemIndicator,
  ec as SelectItemText,
  Qd as SelectLabel,
  Ud as SelectPortal,
  zd as SelectRoot,
  nc as SelectScrollDownButton,
  oc as SelectScrollUpButton,
  Yd as SelectSeparator,
  jd as SelectTrigger,
  ac as SelectValue,
  tc as SelectViewport,
  eu as Separator,
  du as SliderRange,
  ru as SliderRoot,
  lu as SliderThumb,
  uu as SliderTrack,
  us as Slot,
  Zl as SwitchRoot,
  Ql as SwitchThumb,
  su as TabsContent,
  au as TabsList,
  nu as TabsRoot,
  iu as TabsTrigger,
  Ru as ToastAction,
  yr as ToastClose,
  Lu as ToastDescription,
  Mu as ToastProvider,
  ku as ToastRoot,
  Vu as ToastTitle,
  Fu as ToastViewport,
  qs as Toggle,
  ii as ToggleGroupItem,
  si as ToggleGroupRoot,
  br as ToolbarButton,
  Nu as ToolbarLink,
  Ku as ToolbarRoot,
  zu as ToolbarSeparator,
  Hu as ToolbarToggleGroup,
  Wu as ToolbarToggleItem,
  Zu as TooltipArrow,
  Ju as TooltipContent,
  Qu as TooltipPortal,
  qu as TooltipProvider,
  Yu as TooltipRoot,
  Xu as TooltipTrigger,
  Ge as VisuallyHidden,
  le as useEmitAsProps,
  Tt as useForwardProps,
  ue as useForwardPropsEmits,
  te as useId,
  gn as useStateMachine
};
//# sourceMappingURL=radix-vue.js.map
